{
  "layer": 0,
  "alignments": {
    "c30": {
      "encoder_cluster": {
        "id": "c30",
        "unique_tokens": [
          "request",
          ".",
          ")",
          ";",
          "="
        ],
        "syntactic_label": "Method Parameter, Dot Operator, Closing Parenthesis, Semicolon, Assignment Operator",
        "semantic_tags": [
          "Method Invocation",
          "Request Handling",
          "AWS SDK",
          "Parameter Passing",
          "API Interaction"
        ],
        "description": "The tokens represent core elements of a Java method signature and body.  'request' is a method parameter, likely an object containing data for an AWS API request.  '.' is the dot operator used for method calls. ')' closes a parameter list. ';' terminates statements. '=' is the assignment operator. The code snippets show numerous AWS SDK method calls, each taking a 'request' object as input to perform various operations. The semantic tags highlight the overall function of the code within the context of interacting with AWS services."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c469",
          "unique_tokens": [
            "=",
            "buffer",
            "result",
            ":",
            ",",
            "!=",
            ";",
            ")",
            "0",
            ".",
            "}",
            "=="
          ],
          "syntactic_label": "C# Operators and Punctuation",
          "semantic_tags": [
            "Assignment",
            "Comparison",
            "Control Flow",
            "Method Return",
            "Data Structures"
          ],
          "description": "The tokens represent a mix of C# operators and punctuation commonly used in various programming constructs. '=' is the assignment operator, used to assign values to variables. '==' and '!=' are comparison operators, used for conditional checks. ';' is the statement terminator. ',' is used as a separator in lists and method parameters. '()' are parentheses used for function calls and grouping. '{' and '}' are braces used to define code blocks.  The '.' operator is used for member access. '0' is a numeric literal. The tokens are significant in C# as they are fundamental to the syntax and structure of the language, enabling variable assignment, conditional logic, method calls, and data structure manipulation."
        },
        {
          "id": "c403",
          "unique_tokens": [
            "other",
            "=",
            "instanceof",
            "_other",
            "getValue",
            ";",
            ")",
            "."
          ],
          "syntactic_label": "Object-oriented programming constructs, comparison operators, type checking, assignment, method invocation, and statement terminators",
          "semantic_tags": [
            "Object Comparison",
            "Equality Checks",
            "Type Verification",
            "Data Structure Manipulation",
            "Algorithm Implementation"
          ],
          "description": "The tokens represent core elements of object-oriented programming in C#.  'other' and '_other' are parameters representing objects. '=' is the assignment operator. 'instanceof' is a type-checking operator. 'getValue', a method call, retrieves a value from an object. ';' terminates statements. ')' closes parentheses. '.' is the member access operator. These tokens are used extensively in various algorithms and data structure manipulations for comparing and verifying objects."
        },
        {
          "id": "c435",
          "unique_tokens": [
            "repo",
            "=",
            "Repository",
            ",",
            ";",
            ")",
            "."
          ],
          "syntactic_label": "Repository Object, Assignment Operator, Comma, Semicolon, Closing Parenthesis, Dot Operator",
          "semantic_tags": [
            "Git Repository Management",
            "Command Object Instantiation",
            "Git API Interaction",
            "Object Access",
            "Method Chaining"
          ],
          "description": "The tokens represent core elements in the context of Git repository manipulation within a C# application.  'repo' is a Repository object, likely representing a Git repository. '=' is the assignment operator. ',' separates arguments. ';' terminates statements. ')' closes method calls. '.' is the dot operator used for method invocation on the 'repo' object. The code snippets show the creation and usage of various Git commands, all interacting with the 'repo' object.  This pattern suggests a higher-level Git API wrapper or library in C#."
        },
        {
          "id": "c359",
          "unique_tokens": [
            "=",
            ",",
            "searcher",
            ";",
            ")",
            "."
          ],
          "syntactic_label": "Constructor Parameter, Assignment Operator, Comma Operator, Method Parameter, Dot Operator, Closing Parenthesis, Semicolon",
          "semantic_tags": [
            "Search Indexing",
            "Resource Management",
            "Version Control",
            "IndexReader",
            "Searcher Tracking"
          ],
          "description": "The tokens represent core elements of C# syntax within the context of search index management. '=' is the assignment operator, ',' separates parameters, '.' is the dot operator for method calls, and ';' terminates statements.  The repeated use of 'IndexSearcher' as a parameter highlights its central role in managing and accessing search indexes.  The code appears to track searcher instances based on version numbers, ensuring efficient resource management and preventing conflicts.  The semantic tags reflect the overall functionality of managing and tracking search index resources."
        }
      ]
    },
    "c79": {
      "encoder_cluster": {
        "id": "c79",
        "unique_tokens": [
          ")",
          "options",
          "(",
          ";"
        ],
        "syntactic_label": "Parenthesis, Identifier, Parenthesis, Semicolon",
        "semantic_tags": [
          "Method Parameters",
          "Object Instantiation",
          "Method Call",
          "AWS SDK",
          "API Interaction"
        ],
        "description": "These tokens represent common syntactic elements in Java methods, particularly within the context of interacting with the AWS SDK.  The opening and closing parentheses define method parameters, 'options' is an identifier for an object (InvokeOptions), and the semicolon terminates the statement. The code snippets show the pattern of using InvokeOptions to make API calls within the AWS SDK."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c68",
          "unique_tokens": [
            ")",
            "request",
            ";"
          ],
          "syntactic_label": "Method Parameter, Object, Semicolon",
          "semantic_tags": [
            "Request Handling",
            "AWS SDK",
            "Method Invocation",
            "Asynchronous Operations",
            "Client-Side Logic"
          ],
          "description": "The tokens represent key elements in C# methods within an AWS SDK.  'request' is a method parameter, typically an object containing input data for an AWS service operation. ')' signifies the closing parenthesis of the method's parameter list. ';' is used to terminate statements. The semantic tags highlight the overall purpose of the code: handling requests, interacting with the AWS SDK, invoking methods (likely asynchronous), and managing client-side logic."
        }
      ]
    },
    "c80": {
      "encoder_cluster": {
        "id": "c80",
        "unique_tokens": [
          ")",
          "("
        ],
        "syntactic_label": "Parentheses",
        "semantic_tags": [
          "Data Input",
          "Record Construction",
          "Byte Stream Processing",
          "Data Deserialization",
          "File Parsing"
        ],
        "description": "The parentheses '(' and ')' are used extensively in the constructor methods of various record classes. They enclose the parameters passed to the constructors, which are instances of 'RecordInputStream'.  These parameters represent byte streams read from a file, and the code within the parentheses uses methods of 'RecordInputStream' to extract and interpret data from the stream, constructing the corresponding record object.  The semantic tags reflect the overall process of reading, parsing, and deserializing data from a byte stream into specific record structures."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c33",
          "unique_tokens": [
            "isEmpty",
            "{",
            ")",
            "("
          ],
          "syntactic_label": "Method, Boolean method, Opening Parenthesis, Closing Parenthesis, Conditional Statement",
          "semantic_tags": [
            "Empty Collection Check",
            "Error Handling",
            "Input Validation",
            "Resource Management",
            "Configuration"
          ],
          "description": "The tokens are part of a common C# pattern for checking if a collection (Map in this case) is empty.  `isEmpty()` is a method call that returns a boolean indicating whether the map contains any elements. The opening and closing parenthesis `(` and `)` delimit the method's arguments. The curly braces `{` and `}` define a code block that executes if the map is not empty.  The code throws an `IllegalArgumentException` if there are unknown parameters, which is a form of error handling and input validation. This pattern is frequently used in C# applications to ensure that configurations are valid and to prevent unexpected behavior."
        },
        {
          "id": "c390",
          "unique_tokens": [
            "location",
            ")",
            "listIterator",
            "("
          ],
          "syntactic_label": "Parameter, Method, Integer, Opening Parenthesis, Closing Parenthesis",
          "semantic_tags": [
            "List Iteration",
            "Index Access",
            "Data Manipulation",
            "Exception Handling",
            "List Modification"
          ],
          "description": "The tokens represent parameters and method calls related to list iteration in C#.  'location' is an integer parameter representing an index within a list.  'listIterator()' and 'listIterator(int)' are methods that return a ListIterator object for traversing the list. '(' and ')' are used for method calls and parameter grouping. The code demonstrates various operations on lists using iterators, including getting, adding, setting, and removing elements at specific indices.  Exception handling is implemented to manage cases where the index is out of bounds."
        }
      ]
    },
    "c90": {
      "encoder_cluster": {
        "id": "c90",
        "unique_tokens": [
          ";",
          "="
        ],
        "syntactic_label": "Assignment and Statement Separator",
        "semantic_tags": [
          "Variable Initialization",
          "Data Assignment",
          "Statement Termination",
          "Object Construction",
          "Control Flow"
        ],
        "description": "The '=' operator is used for assigning values to variables, such as initializing instance variables in the constructor.  The ';' separates statements, indicating the end of one statement and the beginning of another.  These tokens are fundamental to Java syntax, enabling variable assignments and defining the structure of code blocks."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c74",
          "unique_tokens": [
            "functionName",
            ")",
            "=",
            ";"
          ],
          "syntactic_label": "Function Parameter, Closing Parenthesis, Assignment Operator, Statement Terminator",
          "semantic_tags": [
            "Function Definition",
            "Function Argument",
            "Exception Handling",
            "Function Invocation",
            "Custom Function"
          ],
          "description": "The tokens represent fundamental C# language constructs.  'functionName' acts as a parameter in function definitions, receiving a string value representing a function's name.  ')' closes parameter lists in function declarations and calls. '=' is the assignment operator, used to assign values to variables (like _functionName). ';' terminates statements.  The semantic tags highlight the code's focus on defining, finding, and evaluating custom functions, with exception handling for cases where functions are not implemented."
        },
        {
          "id": "c430",
          "unique_tokens": [
            "=",
            "ord",
            ".",
            ";"
          ],
          "syntactic_label": "Assignment Operator, Variable, Dot Operator, Statement Terminator",
          "semantic_tags": [
            "Ordinal Tracking",
            "Term Position Management",
            "Index Structures",
            "Data Structures",
            "Search Optimization"
          ],
          "description": "The tokens =, ord, ., and ; are fundamental C# language constructs. '=' is the assignment operator, used to assign values to variables. 'ord' appears to be a variable frequently used to represent an ordinal position or index within a data structure, likely related to term positions in an inverted index. '.' is the dot operator, used for member access (e.g., accessing properties or methods of objects). ';' is the statement terminator.  The semantic tags reflect the common usage of these tokens in managing term positions and optimizing search operations within an index structure. The frequent use of 'ord' suggests an underlying data structure that maintains the order of terms or elements, crucial for efficient search and retrieval."
        }
      ]
    },
    "c103": {
      "encoder_cluster": {
        "id": "c103",
        "unique_tokens": [
          "re",
          "VALUE_INVALID",
          "SubtractEval",
          "errorEval",
          "LazyRefEval",
          "GetRefEval",
          "DIV_ZERO",
          "GetErrorEval",
          ";",
          "RefEval",
          "(",
          "StringEval",
          "MissingArgEval",
          "value",
          "MakeConcise",
          "GetInnerValueEval",
          "GetAreaEval",
          "_errorEval",
          "StringValueEval",
          "refEval",
          "ref1",
          "FirstRow",
          "absRowIx",
          "ErrorEval",
          "ve",
          "areaEval",
          "BoolEval",
          ")",
          "FunctionEval",
          "BlankEval",
          "NumberEval",
          "ExternalNameEval",
          "AreaEval",
          ".",
          "ValueEval",
          "LazyAreaEval",
          "placesValueEval",
          "this",
          "NumericValueEval",
          "result",
          "NUM_ERROR",
          "FunctionNameEval",
          "="
        ],
        "syntactic_label": "Java language constructs and identifiers",
        "semantic_tags": [
          "Spreadsheet Evaluation",
          "Formula Evaluation",
          "Error Handling",
          "Value Resolution",
          "Data Structures"
        ],
        "description": "The tokens represent a wide array of Java language constructs, including keywords (=, ;), operators (.), identifiers (e.g., ValueEval, ErrorEval, RefEval), and method calls.  They are part of a larger system for evaluating spreadsheet formulas, handling various data types (numbers, strings, booleans, references), and managing errors during the evaluation process.  The semantic tags highlight the core functionality: evaluating formulas, resolving values from different cell types, handling errors (e.g., #NUM!, #VALUE!), and using data structures (e.g., ValueEval, AreaEval) to represent spreadsheet data."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c497",
          "unique_tokens": [
            "absRowIx",
            "RefEval",
            "FunctionEval",
            "ExternalNameEval",
            ";",
            "AreaEval",
            "(",
            "RefListEval",
            "NumericValueEval",
            "_errorEval",
            "getFirstRow",
            "LazyAreaEval",
            "refEval",
            "FunctionNameEval",
            "getRefEval",
            "lazyRefEval",
            "BoolEval",
            "placesValueEval",
            "NumberEval",
            "BlankEval",
            "StringValueEval",
            "StringEval",
            "=",
            "LazyRefEval",
            "getErrorEval",
            "errorEval",
            "getInnerValueEval",
            "getAreaEval",
            "ValueEval",
            "ErrorEval",
            "MissingArgEval",
            "areaEval"
          ],
          "syntactic_label": "C# Spreadsheet Evaluation Objects and Methods",
          "semantic_tags": [
            "Spreadsheet Evaluation",
            "Formula Evaluation",
            "Error Handling",
            "Cell Referencing",
            "Data Type Conversion"
          ],
          "description": "The tokens represent objects and methods involved in evaluating spreadsheet formulas in C#.  They handle various data types (numbers, strings, errors), cell references, and error conditions.  The methods perform calculations and return results as ValueEval objects, which encapsulate different data types and error states.  The semantic tags reflect the core functionality of the code, which is to process and evaluate spreadsheet formulas."
        }
      ]
    },
    "c106": {
      "encoder_cluster": {
        "id": "c106",
        "unique_tokens": [
          "definedNameIndex",
          "GetFormatIndex",
          "shardIndex",
          "_rowIndex",
          "ReaderIndex",
          "location",
          "GetFontIndex",
          ":",
          "field_6_backcolorIndex",
          "DeltaIndex",
          "ToBlockIndex",
          "p",
          "int",
          "AdjustIndex",
          "RuleIndex",
          "RowIndex",
          "idx",
          "_sheetEvaluators",
          "FontIndex",
          "ConvertFromExternSheetIndex",
          "AdjustSeekIndex",
          "lastLocalSheetIndex",
          "CheckRuleIndex",
          "SheetRefIndex",
          "field_1_last_column_index",
          "GetSheetIndex",
          "ExternSheetIndex",
          "byteIndex",
          "firstTabIndex",
          "_fontIndex",
          ">",
          "col_index",
          "SetIndex",
          "_columnIndex",
          "CheckIndex",
          "lstartIndex",
          "fontIndex",
          "backIndex",
          "NotImplementedFunction",
          "bounds:",
          "reFindex",
          "!=",
          "_startIndex",
          "sequenceIndex",
          "1",
          "does",
          "predIndex",
          "refIndex",
          "XFIndex",
          "_nextIndex",
          "field_1_index",
          "return",
          "m_fontIndex",
          "outside",
          "GetLastInternalSheetIndexForExtIndex",
          "actionIndex",
          "lastSheetIndex",
          "FindSheetNameFromIndex",
          "ShardIndex",
          "extBookIndex",
          "_index",
          "_writeIndex",
          "formatIndex",
          "separatorIndex",
          "FindRefIndexFromExtBookIndex",
          "sb",
          "_sheetIndex",
          "startRuleIndex",
          "Index",
          "GetNameIndex",
          "index",
          "GetExternalSheetIndex",
          "cellIndex",
          "invert",
          "positionIndex",
          "findIndex",
          "'",
          "ColorPaletteIndex",
          "LookupIndex",
          "extRefIndex",
          "rstartIndex",
          "supLinkIndex",
          "srcSheetIndex",
          "field_5_colourPaletteIndex",
          "BeginIndex",
          "functionIndex",
          ")",
          "GetRuleIndex",
          "\"",
          "buf",
          "currentExternSheetIndex",
          "localSheetIndex",
          "NameIndex",
          "checkIndex",
          "_lastSheetIndex",
          "extBlockIndex",
          "field_3_color_palette_index",
          "docsInFirstIndex",
          "GetIndex",
          "sheetIndex",
          "==",
          "repo",
          "externNameIndex",
          "&&",
          "thisSheetRefIndex",
          "=",
          "if",
          "field_2_first_column_index",
          "BlockIndex",
          "field_3_row_index",
          "GetFirstSheetIndexFromExternSheetIndex",
          "bookIndex",
          "field_1_formatIndex",
          "_ReadIndex",
          "FirstSheetIndex",
          "pictureIndex",
          "GetFunctionIndex",
          "GetValueIndex",
          "GetFirstSheetIndexFromRefIndex",
          "++",
          "func",
          "ToDirectoryIndex",
          "ColumnIndex",
          "tokens",
          "for",
          "negative:",
          "getEndIndex",
          "formattingFontIndex",
          "GetLastSheetIndexFromExternSheetIndex",
          "<",
          "GetSequenceIndex",
          "treeIndex",
          "forwardIndex",
          "0",
          "GetLastSheetIndexFromRefIndex",
          "input",
          "currentCharIndex",
          "CreateIndex",
          "_tokenStartCharIndex",
          "dstSheetIndex",
          "TokenIndex",
          "sheetRefIndex",
          "PackIndex",
          "}",
          "field_1_xf_index",
          "_bookIndex",
          ",",
          "filterDbNameIndex",
          "currentBlockIndex",
          ".",
          "styleIndex",
          "GetExtbookIndexFromRefIndex",
          "]",
          "removalIndex",
          "-",
          "_sheetRefIndex",
          "Append",
          "StopIndex",
          "shortIndex",
          "externSheetIndex",
          ">=",
          "LastSheetIndex",
          "WriteIndex",
          "PictureIndex",
          "ListIndex",
          "field_2_seriesIndex",
          "TermsEnumIndex",
          "{",
          "nameIndex",
          "_functionIndex",
          "blockIndex",
          ";",
          "EndIndex",
          "(",
          "firstSheetIndex",
          "commit",
          "stopIndex",
          "patternRuleIndex",
          "GetFirstInternalSheetIndexForExtIndex",
          "externalBookIndex",
          "+",
          "field_1_font_index",
          "previousIndex",
          "GetExternalWorkbookIndex",
          "newSheetIndex",
          "field_5_forecolorIndex",
          "longIndex",
          "tailIndex",
          "skipped",
          "thisWbIndex",
          "payloadIndex",
          "CharIndex",
          "field_1_chartGroupIndex",
          "headIndex",
          "x",
          "ActiveSheetIndex",
          "offset",
          "field_2_format_index",
          "ruleIndex",
          "field_1_label_index",
          "_extBookIndex",
          "this",
          "_firstSheetIndex",
          "_xf_index",
          "snapshot",
          "DetachFromIndex",
          "SubIndex"
        ],
        "syntactic_label": "Index identifiers, variables, and operators",
        "semantic_tags": [
          "Index Management",
          "Data Access",
          "Control Flow",
          "Iteration",
          "Conditional Logic"
        ],
        "description": "The tokens represent a mix of index identifiers (e.g., `definedNameIndex`, `ruleIndex`, `sheetIndex`), variables (`sb`, `p`, `index`), and operators (`=`, `!=`, `++`, `&&`, `>`, `<`, `==`, `+`, `-`).  These are fundamental to Java programming, particularly in scenarios involving data structures, loops, and conditional logic. The context sentences show their use in accessing and manipulating data within various data structures, controlling program flow (e.g., loops and conditional statements), and performing calculations or comparisons."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c220",
          "unique_tokens": [
            "backIndex",
            "field_3_row_index",
            "getFirstSheetIndexFromExternSheetIndex",
            "lastSheetIndex",
            "'",
            "newSheetIndex",
            "toBlockIndex",
            "actionIndex",
            "localSheetIndex",
            "getXFIndex",
            "sinceLastIndex",
            "isLeafNode",
            "updateIndex",
            "-",
            "bookIndex",
            "getCharIndex",
            ":",
            "_fontIndex",
            "getExtbookIndexFromRefIndex",
            "readerIndex",
            "patternRuleIndex",
            "functionIndex",
            "getExternSheetIndex",
            "getSequenceIndex",
            "field_5_colourPaletteIndex",
            "field_1_font_index",
            "separatorIndex",
            "getStopIndex",
            "field_1_label_index",
            "lookupIndex",
            ".",
            "predIndex",
            "checkElementIndex",
            "lastColumnIndex",
            "sb",
            "firstSheetIndex",
            "externNameIndex",
            "getFirstInternalSheetIndexForExtIndex",
            "pictureIndex",
            "getLastSheetIndex",
            "convertFromExternSheetIndex",
            "getLastInternalSheetIndexForExtIndex",
            "TermsEnumIndex",
            "workingTreeIndex",
            "formatIndex",
            "_startIndex",
            "==",
            "field_2_seriesIndex",
            "offset",
            "_sheetEvaluators",
            "getNameIndex",
            "p",
            "if",
            "getTokenIndex",
            "_xfIndex",
            "1",
            "thisSheetRefIndex",
            "byteIndex",
            "externalBookIndex",
            "field_5_forecolorIndex",
            "field_1_index",
            "lastLocalSheetIndex",
            "onlySheetIndex",
            "_tokenStartCharIndex",
            "getFirstSheetIndex",
            ";",
            "_columnIndex",
            "supLinkIndex",
            "+",
            "_writeIndex",
            "nameIndex",
            "(",
            "getColumnIndex",
            "startRuleIndex",
            "_rowIndex",
            "getSheetRefIndex",
            "checkPositionIndex",
            "_firstSheetIndex",
            "append",
            "HexDump",
            "getLastIndex",
            "_firstColumnIndex",
            "thisWbIndex",
            "ruleIndex",
            "executeListIndex",
            "headIndex",
            "extBookIndex",
            "previousIndex",
            "getExternalWorkbookIndex",
            "firstTabIndex",
            "removalIndex",
            "field_6_backcolorIndex",
            "executeDetachFromIndex",
            "styleIndex",
            "findIndex",
            "getFormatIndex",
            "appendValueText",
            "stopIndex",
            "getExternalSheetIndex",
            "extRefIndex",
            "shortIndex",
            "srcColumnIndex",
            "field_2_format_index",
            "getFontIndex",
            "field_1_last_column_index",
            "hitIndex",
            "blockIndex",
            "field_1_xf_index",
            "shardIndex",
            "sheetRefIndex",
            "longIndex",
            "PackIndex",
            "dirCacheIndex",
            "extBlockIndex",
            "setPictureIndex",
            "currentExternSheetIndex",
            ">=",
            "getColorPaletteIndex",
            "}",
            "detachFromIndex",
            "forIndex",
            "adjustIndex",
            "_sheetRefIndex",
            "index",
            "filterDbNameIndex",
            "setXFIndex",
            "payloadIndex",
            "subIndex",
            "currentBlockIndex",
            "tailIndex",
            "externSheetIndex",
            "treeIndex",
            "docsInFirstIndex",
            "srcSheetIndex",
            "_extBookIndex",
            "dstSheetIndex",
            "findRefIndexFromExtBookIndex",
            "formattingFontIndex",
            "fontIndex",
            "getEndIndex",
            "field_3_color_palette_index",
            "_bookIndex",
            "Index",
            "=",
            "sequenceIndex",
            "cellIndex",
            "outside",
            "executeCreateIndex",
            "setExternSheetIndex",
            "tokenIndex",
            "setFontColorIndex",
            "forwardIndex",
            "getRuleIndex",
            "field_1_formatIndex",
            "getFunctionIndex",
            "<",
            "firstColumnIndex",
            "getActiveSheetIndex",
            "getWriteIndex",
            "_lastSheetIndex",
            "getValueIndex",
            "lstartIndex",
            "_nextIndex",
            "_index",
            "getBeginIndex",
            "sheetIndex",
            "getRowIndex",
            ",",
            "col_index",
            "]",
            "positionIndex",
            "rstartIndex",
            "field_1_chartGroupIndex",
            "_lastColumnIndex",
            "adjustSeekIndex",
            "definedNameIndex",
            "checkRuleIndex",
            "checkIndex",
            "field_2_first_column_index",
            "toDirectoryIndex",
            "for",
            ">",
            "_sheetIndex",
            "listIndex",
            "\"",
            "refIndex",
            "{",
            "getFirstSheetIndexFromRefIndex",
            "getLastSheetIndexFromRefIndex",
            "getLastSheetIndexFromExternSheetIndex",
            "findSheetNameFromIndex",
            "relativeColumnIndex",
            "getSheetIndex",
            ")",
            "currentCharIndex",
            "DeltaIndex"
          ],
          "syntactic_label": "Index identifiers, methods, operators, and keywords",
          "semantic_tags": [
            "Index Management",
            "Data Access",
            "Conditional Logic",
            "Data Processing",
            "Spreadsheet Manipulation"
          ],
          "description": "The tokens represent a wide range of elements crucial for spreadsheet data manipulation in C#.  'Index' identifiers (e.g., `row`, `col`, `pictureIndex`, etc.) are used extensively to access and manipulate data within spreadsheet structures.  Methods like `getAbsoluteValue`, `evaluate`, `insert`, etc., perform calculations and data transformations. Operators such as `==`, `>=`, `<`, `+`, `-`, and the dot operator (`.`) are used for comparisons, arithmetic operations, and method calls. Keywords like `if`, `for`, `return`, etc., control the flow of execution and data handling within the code."
        }
      ]
    },
    "c151": {
      "encoder_cluster": {
        "id": "c151",
        "unique_tokens": [
          "nio",
          ".",
          "charset"
        ],
        "syntactic_label": "Java Package and Class Names, Dot Operator, and Class Member",
        "semantic_tags": [
          "Character Encoding",
          "Input/Output",
          "Buffer Management",
          "Data Handling",
          "NIO API"
        ],
        "description": "The tokens 'nio', '.', and 'charset' are part of the Java NIO (New I/O) API.  'nio' refers to the package containing classes for non-blocking I/O operations.  '.' is the dot operator used to access members of classes (methods, fields). 'charset' refers to the class within the 'java.nio.charset' package that deals with character encodings.  These tokens and the context sentences demonstrate the use of NIO classes for buffer management, character encoding handling, and input/output operations."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c33",
          "unique_tokens": [
            "isEmpty",
            "{",
            ")",
            "("
          ],
          "syntactic_label": "Method, Boolean method, Opening Parenthesis, Closing Parenthesis, Conditional Statement",
          "semantic_tags": [
            "Empty Collection Check",
            "Error Handling",
            "Input Validation",
            "Resource Management",
            "Configuration"
          ],
          "description": "The tokens are part of a common C# pattern for checking if a collection (Map in this case) is empty.  `isEmpty()` is a method call that returns a boolean indicating whether the map contains any elements. The opening and closing parenthesis `(` and `)` delimit the method's arguments. The curly braces `{` and `}` define a code block that executes if the map is not empty.  The code throws an `IllegalArgumentException` if there are unknown parameters, which is a form of error handling and input validation. This pattern is frequently used in C# applications to ensure that configurations are valid and to prevent unexpected behavior."
        },
        {
          "id": "c194",
          "unique_tokens": [
            "(",
            "clone"
          ],
          "syntactic_label": "Method and Opening Parenthesis",
          "semantic_tags": [
            "Object Cloning",
            "Deep Copy",
            "Defensive Copying",
            "Data Integrity",
            "Object Serialization"
          ],
          "description": "The token '(' acts as an Opening Parenthesis, part of method signatures. The token 'clone' is a method name frequently used to create a copy of an object.  In C#, the clone method is used to create a copy of an object. The context shows various implementations of the clone method, some creating shallow copies (using a simple copy method) and others creating deep copies (recursively cloning member objects). This is crucial for maintaining data integrity and preventing unintended side effects when modifying cloned objects.  The examples demonstrate different approaches to cloning, highlighting the importance of understanding the implications of shallow vs. deep copying."
        },
        {
          "id": "c132",
          "unique_tokens": [
            "super",
            ".",
            "("
          ],
          "syntactic_label": "Constructor Invocation",
          "semantic_tags": [
            "Inheritance",
            "Object Creation",
            "Class Initialization",
            "Method Chaining",
            "Base Class Constructor"
          ],
          "description": "The tokens `super`, `.` and `(` are used together to invoke the constructor of the base class (superclass) within the constructors of derived classes.  The `super` keyword explicitly calls the base class constructor, the `.` is the member access operator, and `(` indicates the start of the argument list for the base class constructor. This is a fundamental aspect of inheritance in C#, enabling the reuse of code and establishment of an \"is-a\" relationship between classes."
        },
        {
          "id": "c101",
          "unique_tokens": [
            "_byteEncoding",
            "=",
            "guessEncoding",
            "getPreferredEncoding",
            "parseEncoding",
            "setEncoding",
            "("
          ],
          "syntactic_label": "Encoding Methods and Properties",
          "semantic_tags": [
            "Encoding",
            "Serialization",
            "Character Encoding",
            "Data Processing",
            "Text Handling"
          ],
          "description": "The tokens represent methods and properties related to character encoding in C#.  `_byteEncoding` appears to be a byte array storing encoded data.  `guessEncoding`, `setEncoding`, `parseEncoding`, and `getPreferredEncoding` are methods for handling character encodings, likely converting between different encoding schemes. The `=` operator is used for assignment, and `(` is an opening parenthesis used in method calls. These are crucial for handling text data correctly, especially when dealing with different character sets and internationalization."
        },
        {
          "id": "c388",
          "unique_tokens": [
            "getChar",
            "\"",
            "setText",
            "getText",
            ")",
            "("
          ],
          "syntactic_label": "Methods and String Manipulation",
          "semantic_tags": [
            "Text Processing",
            "Parsing",
            "Tokenization",
            "String Extraction",
            "Data Retrieval"
          ],
          "description": "The tokens represent methods used for retrieving and manipulating text data, particularly within a parsing or tokenization context.  `getText` and `getChar` methods extract textual information from various data structures (e.g., trees, intervals, tokens). `setText` methods modify or set the text content of objects. The parentheses '(' and ')' are used for method calls and parameter passing.  These are common operations in C# applications that deal with text-based data, such as compilers, parsers, or text editors."
        },
        {
          "id": "c390",
          "unique_tokens": [
            "location",
            ")",
            "listIterator",
            "("
          ],
          "syntactic_label": "Parameter, Method, Integer, Opening Parenthesis, Closing Parenthesis",
          "semantic_tags": [
            "List Iteration",
            "Index Access",
            "Data Manipulation",
            "Exception Handling",
            "List Modification"
          ],
          "description": "The tokens represent parameters and method calls related to list iteration in C#.  'location' is an integer parameter representing an index within a list.  'listIterator()' and 'listIterator(int)' are methods that return a ListIterator object for traversing the list. '(' and ')' are used for method calls and parameter grouping. The code demonstrates various operations on lists using iterators, including getting, adding, setting, and removing elements at specific indices.  Exception handling is implemented to manage cases where the index is out of bounds."
        },
        {
          "id": "c421",
          "unique_tokens": [
            "\"",
            "EOF",
            "append",
            "containsChart",
            "chart",
            "("
          ],
          "syntactic_label": "Method, Variable, Class, Object, Comma, Opening Parenthesis, End Of File",
          "semantic_tags": [
            "Chart Data Processing",
            "Data Structures",
            "File Parsing",
            "Object Manipulation",
            "Exception Handling"
          ],
          "description": "The tokens represent various elements in C# code related to chart data processing.  'EOF' signifies the end of a data stream. 'append' is a method used to add data to a StringBuilder object. 'containsChart' is likely a method to check for the presence of chart data. 'chart' is likely a class or object related to chart data.  The comma acts as a separator, and the opening parenthesis indicates method calls or object instantiation. These elements work together to parse and process chart data from a file or stream, handling potential errors along the way."
        },
        {
          "id": "c453",
          "unique_tokens": [
            "readLong",
            "("
          ],
          "syntactic_label": "Method Name and Opening Parenthesis",
          "semantic_tags": [
            "Data Input",
            "Binary Data",
            "Data Decoding",
            "File Reading",
            "Data Representation"
          ],
          "description": "The token 'readLong' is a method name that reads a long integer from a binary data source. The opening parenthesis '(' indicates the start of the method's parameter list.  These are frequently used in file I/O operations or when dealing with binary data formats where data is represented as a sequence of bytes. The context shows it's used to read long integers from various input streams (files, byte arrays)."
        },
        {
          "id": "c340",
          "unique_tokens": [
            "Term",
            "other",
            "getValue",
            "cell",
            ")",
            "equals",
            "("
          ],
          "syntactic_label": "Method parameters, local variables, method calls, Object, Dot operator, Equality operators",
          "semantic_tags": [
            "Object comparison",
            "Data processing",
            "Input/Output operations",
            "String manipulation",
            "Conditional logic"
          ],
          "description": "The tokens represent various elements in C# methods.  'Term', 'other', and 'cell' appear to be object names or variables. 'getValue' suggests a method call to retrieve a value.  'equals' is used for object comparison. '(' and ')' are parentheses for method calls and conditional statements. The code snippets show various operations including string manipulation using StringBuilder, object comparisons using equals(), and conditional logic using if statements.  The overall purpose seems to be data processing and object manipulation."
        },
        {
          "id": "c86",
          "unique_tokens": [
            "(",
            "synchronized",
            "static"
          ],
          "syntactic_label": "Modifiers",
          "semantic_tags": [
            "Synchronization",
            "Concurrency Control",
            "Static Methods",
            "Method Access",
            "Class Member"
          ],
          "description": "The tokens (, synchronized, and static are modifiers in C#.  '(' is an opening parenthesis used in method declarations and calls. 'synchronized' is used to control access to methods, ensuring thread safety by synchronizing on the object instance. 'static' indicates that the method belongs to the class itself, not a specific instance of the class."
        },
        {
          "id": "c151",
          "unique_tokens": [
            "\"",
            "match",
            "replaceAll",
            "putInt",
            "put",
            "("
          ],
          "syntactic_label": "Method and Map",
          "semantic_tags": [
            "Data Structures",
            "Data Serialization",
            "Method Invocation",
            "Map Operations",
            "Data Storage"
          ],
          "description": "The tokens represent methods related to data manipulation and storage, primarily using map data structures.  The `put` methods are used extensively to insert data into maps and other data structures. The comma acts as a separator in method parameters and arguments. `replaceAll` suggests string manipulation, while `match` implies pattern matching. The opening parenthesis '(' indicates the start of method parameters."
        }
      ]
    },
    "c167": {
      "encoder_cluster": {
        "id": "c167",
        "unique_tokens": [
          "field_5_x",
          "sIx",
          "(0x",
          "ShortToHex",
          "lowValidIx",
          "rowIx",
          "_highIx",
          "rowOffsetIx",
          "relFirstRowIx",
          "ToIx",
          "X",
          "0x",
          "Ix",
          "relLastRowIx",
          "field_1_x",
          "FirstColumn",
          "relFirstColIx",
          "!=",
          "1",
          "scaleX",
          "RowCount",
          "XFIndex",
          "ebIx",
          "return",
          "MaxX",
          "fromIx",
          "midIx",
          "columnIx",
          "buffer",
          "GetHighIx",
          ")",
          "newExtSheetIx",
          "\"",
          "field_3_y",
          "NumberEval",
          "kx",
          "is",
          "GetNameIx",
          "field_6_y",
          "_lowIx",
          "ePowNegX",
          "Options",
          "=",
          "highValidIx",
          "AppendValueText",
          "rcIx",
          "_evaluator",
          "rrIx",
          "relLastColIx",
          "_workbookIx",
          "LastRow",
          "MinX",
          "colOffsetIx",
          "startIx",
          "-=",
          "GetSheetExtIx",
          "currentExternSheetIx",
          "GetMidIx",
          "specifiy",
          "0",
          "ePowX",
          "LastColumn",
          ",",
          ".",
          "y",
          "-",
          "edx",
          "Append",
          "ColumnCount",
          "{",
          ";",
          "(",
          "ResolveNameXIx",
          "_endIx",
          "FirstRow",
          "+",
          "isxvi",
          "extIx",
          "vvX",
          "colIx",
          "x",
          "field_2_y",
          "GetLowIx",
          "field_2_x",
          "["
        ],
        "syntactic_label": "Variables, Objects, Methods, Operators, and Literals",
        "semantic_tags": [
          "Data Structures",
          "File I/O",
          "Data Representation",
          "Mathematical Operations",
          "String Manipulation"
        ],
        "description": "The tokens represent a mix of data structures (variables, objects like StringBuilder), file I/O operations (reading and writing data), data representation (hexadecimal conversions), mathematical operations (e.g., Math.Pow), and string manipulation (using StringBuilder).  The code snippets show various methods that perform these operations, often related to data processing and formatting.  The special characters are used for method calls, array indexing, and arithmetic operations."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c329",
          "unique_tokens": [
            "sIx",
            "shortToHex",
            "!=",
            "midIx",
            "relLastRowIx",
            "field_1_x",
            ";",
            "highValidIx",
            "getOptions",
            "_workbookIx",
            "resolveNameXIx",
            "_lowIx",
            "rowIx",
            "v",
            "(",
            "return",
            "toIx",
            "getSheetExtIx",
            "fromIx",
            "currentExternSheetIx",
            "ebIx",
            "getMaxX",
            "x",
            "getFirstColumn",
            "(0x",
            "rrIx",
            "append",
            "getFirstRow",
            "isxvi",
            "_highIx",
            "]",
            "++",
            "highIx",
            "getNameIx",
            "colIx",
            "trim",
            "kx",
            ".",
            "columnIx",
            "lowValidIx",
            "getLastRow",
            "getMidIx",
            "field_5_x",
            "scaleX",
            "vvX",
            "_endIx",
            "getIx",
            "relLastColIx",
            "rowOffsetIx",
            "getHighIx",
            "=",
            "ePowX",
            "_evaluator",
            "{",
            "field_2_x",
            "relFirstColIx",
            "startIx",
            "\"",
            "getLowIx",
            "colOffsetIx",
            "extIx",
            "rcIx",
            "getLastColumn",
            "newExtSheetIx",
            "relFirstRowIx",
            "0x",
            ")",
            "getMinX",
            "ePowNegX"
          ],
          "syntactic_label": "Variables, Methods, Operators, and Control Flow",
          "semantic_tags": [
            "Spreadsheet Data Manipulation",
            "Cell Range Processing",
            "Index Management",
            "Formula Evaluation",
            "Data Serialization"
          ],
          "description": "The tokens represent a mix of variables (e.g., rowIx, colIx, _highIx), method calls (e.g., getFirstRow, getLastColumn, getRelativeValue), operators (e.g., =, +, -, !=, <, >), and control flow statements (e.g., if, for).  These are fundamental C# constructs used extensively in the context of spreadsheet data manipulation, specifically focusing on cell ranges, index management within those ranges, formula evaluation, and data serialization. The code appears to be part of a library or application designed to interact with spreadsheet data, possibly in a format like Excel."
        }
      ]
    },
    "c185": {
      "encoder_cluster": {
        "id": "c185",
        "unique_tokens": [
          "append",
          "ToString",
          "return",
          "m_buf",
          ";",
          "(",
          "GetOffset",
          "depth=",
          "+",
          "zbuf",
          ")",
          "_buf",
          "buf",
          "\"",
          "newbuf",
          ",",
          ".",
          "Append",
          "==",
          "="
        ],
        "syntactic_label": "Methods, Variables, Operators",
        "semantic_tags": [
          "String Manipulation",
          "Data Input/Output",
          "Buffer Management",
          "Exception Handling",
          "Object Serialization"
        ],
        "description": "The tokens represent a mix of methods (append, ToString, GetOffset), variables (m_buf, buf, zbuf, newbuf), and operators (+, =, ==, ., etc.).  These are fundamental to Java programming, particularly in handling data streams, buffers, and string manipulation.  The context shows their use in various scenarios, including creating and manipulating strings, reading and writing data to buffers, and handling exceptions (e.g., IOException).  The semantic tags reflect the diverse functionality demonstrated in the code snippets."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c257",
          "unique_tokens": [
            "newbuf",
            ";",
            "0",
            "buf",
            "}",
            "(",
            "toString",
            "new",
            ",",
            "append",
            ".",
            "_buf",
            "try",
            "==",
            "=",
            "\"",
            "depth=",
            "length",
            "[",
            "return",
            "zbuf"
          ],
          "syntactic_label": "C# language constructs and data structures",
          "semantic_tags": [
            "Byte Streams",
            "Buffer Manipulation",
            "String Handling",
            "Exception Handling",
            "Input/Output Operations"
          ],
          "description": "The tokens represent a variety of C# language constructs, including array manipulation, string handling using StringBuilder, exception handling with try-catch blocks, and input/output operations.  The tokens such as `buf`, `newbuf`, `append`, `.`, `toString`, `length`, `[]`, `=`, `==`, `new`, `try`, `catch`, `return`, and others are used in the context of creating, manipulating, and reading from byte arrays and character arrays.  The semantic tags reflect the common operations performed on these data structures within the provided code snippets."
        },
        {
          "id": "c111",
          "unique_tokens": [
            "'",
            "<",
            "instanceof",
            "rules",
            "null",
            "val",
            ";",
            "+",
            ">=",
            "0",
            "subs",
            "}",
            "(",
            "fis",
            "-",
            "toString",
            "serializerClasses",
            "buffer",
            "index",
            "terms",
            "valuesPerBlock",
            ",",
            ":",
            "toIndex",
            "i",
            "--",
            "]",
            "append",
            "++",
            "bitsPerValue",
            "utf8ToString",
            ".",
            "&&",
            "CTFormat",
            "rs",
            "b",
            ">",
            "==",
            "=",
            "\"",
            "{",
            "nCells",
            "3",
            "length",
            ")",
            "return"
          ],
          "syntactic_label": "C# Tokens and Symbols",
          "semantic_tags": [
            "Looping and Iteration",
            "String Manipulation",
            "Array Processing",
            "Conditional Logic",
            "Data Structures"
          ],
          "description": "The tokens represent a wide range of C# language constructs.  Many are used in loops (for, ++, --), array manipulation (array indexing, length property), string building (StringBuilder, append, toString), conditional statements (if, ==, <, >, >=, &&), and general data structure usage (arrays, lists, objects).  The semantic tags reflect the common operations performed in the provided code snippets."
        }
      ]
    },
    "c238": {
      "encoder_cluster": {
        "id": "c238",
        "unique_tokens": [
          "byteLength",
          "bucket",
          ";",
          "(",
          "value",
          "word",
          "byte",
          "separator",
          "active",
          ")",
          "Length",
          "wmfImageLength",
          "base10byte",
          "type",
          ".",
          "]",
          "newSize",
          "upto",
          "[",
          "sbyte"
        ],
        "syntactic_label": "Byte array and primitive datatypes",
        "semantic_tags": [
          "Byte array manipulation",
          "Data Structures",
          "Data encoding",
          "Data processing",
          "Low-level operations"
        ],
        "description": "The tokens represent byte arrays and primitive datatypes frequently used in Java for low-level data manipulation, encoding, and processing.  The context shows these are used extensively in handling binary data, often within the context of file I/O, data serialization, and other operations that require direct interaction with byte streams."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c299",
          "unique_tokens": [
            "'",
            "1",
            "data",
            "!=",
            "8",
            ";",
            "else",
            "(",
            "upto",
            "newSize",
            ".value",
            "base10byte",
            ",",
            "]",
            "8192",
            "byte",
            ".",
            "ArrayUtil",
            "pointer",
            "but",
            "b",
            "originalLength",
            "==",
            "bytes",
            "=",
            "\"",
            "must",
            "offset",
            "{",
            "wmfImageLength",
            "written",
            "value",
            "length",
            "bucket",
            ")",
            "[",
            "if"
          ],
          "syntactic_label": "C# Tokens and Symbols",
          "semantic_tags": [
            "Byte array manipulation",
            "Data serialization",
            "Exception handling",
            "File I/O",
            "Data structures"
          ],
          "description": "The tokens represent a wide range of C# language constructs used in byte array manipulation, data serialization, exception handling, file I/O operations, and data structure management.  The code snippets show various methods that read, write, copy, and process byte arrays, often within the context of serialization or deserialization of data.  The use of exceptions is prevalent for error handling, and the code interacts with external data sources (files, streams).  Data structures like byte arrays, StringBuilders, and custom classes are used to manage and process data efficiently."
        }
      ]
    },
    "c275": {
      "encoder_cluster": {
        "id": "c275",
        "unique_tokens": [
          "strVal",
          "of",
          "m_basicModel",
          "bufferSize",
          "len",
          ":",
          "key",
          "']'",
          "streamName",
          "height",
          "spec",
          "extra",
          "maxFacetDepth",
          "int",
          "name",
          "exceptions",
          "GetType",
          "minTargetSize",
          "rec",
          "d",
          "policy",
          "forwardCount",
          "startOffset",
          "numBytes",
          "maxWriteLen",
          "maxMergeCount",
          "Score",
          "cell",
          "Use",
          "Constants",
          "in",
          "up",
          "aborting",
          "not",
          "7",
          ">",
          ",bytes.length=",
          "Arrays",
          "dateTimeInstance2",
          "3",
          "fsaState",
          "minShingleSize",
          "bitsPerValue",
          "12",
          "expected",
          "m_normalization",
          "m_distribution",
          "CountEntries",
          "sid",
          "!=",
          "1",
          "(R2",
          "latitude",
          "J2N",
          "Prefix",
          "XFIndex",
          "columnIndex",
          "floatExc",
          "_cellType",
          "m_prefix",
          "ToHexString",
          "maxShingleSize",
          "return",
          "relativeOffset",
          "attribute",
          "instead",
          "d+",
          "locale",
          "path",
          "extBookIndex",
          "min",
          "synonyms",
          "value",
          "LUCENE_MAIN_VERSION",
          "formatIndex",
          "_writeIndex",
          "(R1",
          "rc",
          "lockName",
          "sb",
          "m_buffer",
          "interval",
          "errMsg",
          "format",
          "start",
          "index",
          "docBase",
          "commits",
          "nNames",
          "LockFactory",
          "fieldNumber",
          "in1",
          "i",
          "base",
          "'",
          "at",
          "buffer",
          "pos",
          "weight",
          "end",
          ")",
          "Maximum",
          "\"",
          "buf",
          "_size",
          "entry",
          ",i",
          "actualChecksum",
          "from",
          "status",
          "2",
          "is",
          "a",
          "subSlice",
          "TotalTermFreq",
          "byteCount",
          "xfs",
          "numfonts",
          "sec",
          "?",
          "sheetIndex",
          "code",
          "Flag",
          "cannot",
          "field_1_number_of_sheets",
          "(CT",
          "DICTIONARY",
          "message",
          "m_queries",
          "R1",
          "if",
          "str",
          "numDocs",
          "fontName",
          "=",
          "flag",
          "fastForward",
          "begin",
          "v",
          "firstSheetIndex:",
          "but",
          "output",
          "gridH",
          "leq",
          "version",
          "Format",
          "bytes",
          "margin",
          "size",
          "...",
          "tokens",
          "affixFile",
          "bytesRemaining",
          "StringUtil",
          "PathString",
          "dictionaries",
          "nl",
          "fieldName",
          "gridW",
          "alt",
          "HitIndex",
          "e",
          "cc",
          "m_lambda",
          "32",
          "m_afterEffect",
          ").",
          "_endIndex",
          "..",
          "GetChild",
          "MAX_POINTS",
          "replacement_1",
          "lineNumber",
          "param",
          ",length=",
          "}",
          "suffix",
          "found",
          ",",
          "RamUsageEstimator",
          ".",
          "main",
          "label",
          "y",
          "]",
          "analyzerName",
          "state",
          "CellType",
          "maxVersion",
          "Append",
          "codec",
          "\\\"",
          "SourceFiles",
          ".flags",
          "newColumn",
          "Lexer",
          "forceUpdate",
          "other",
          "analyzer",
          "impl",
          "blockFP=",
          "WriteIndex",
          "ToString",
          "RecordName",
          "searcher",
          "fields",
          "nameIndex",
          "{",
          "match",
          "pt",
          ";",
          "expectedOldObjectId",
          "(",
          "be",
          "subs",
          "c:",
          "stream",
          "new,",
          "length_1",
          "units",
          "dfa",
          "fileName",
          "number",
          "shape",
          "+",
          "DocFreq",
          "newPath",
          "bufferPosition",
          "classNamesLocation",
          "P_FLAGS",
          "LEMMATIZER_MODEL",
          "n",
          "doc",
          "gets",
          "BitsPerValue",
          "OperatorName",
          "pEntityName",
          "6",
          "subRecordData",
          "):",
          "FieldsData",
          "CODEC_MAGIC",
          "Length",
          "Cost",
          "minSize",
          "buckets",
          "Target",
          "to",
          "@",
          "position",
          "curGen",
          "ADDINDEXES_INPUT_DIR",
          "newObjectId",
          "num",
          "bytesStart",
          "host",
          "MAXIMUM_SUPPORTED_DISTANCE",
          "offset",
          "type",
          "length",
          "Label",
          "inc",
          "row",
          "this",
          "supported.",
          "docID",
          "width",
          "DATA_SIZE",
          "lexState",
          "only",
          "snapshot",
          "[",
          "rowIndex"
        ],
        "syntactic_label": "Variables, Keywords, Operators, Method invocations,identifiers",
        "semantic_tags": [
          "Data Structures",
          "Control Flow",
          "Input/Output",
          "Exception Handling",
          "Text Processing"
        ],
        "description": "The tokens represent a mix of data types (int, string, long, etc.), keywords (if, else, return, etc.), operators (=, !=, +, etc.), method invocations (e.g., append, ToString, etc.), and identifiers (variable and function names).  These elements are fundamental to Java programming, enabling the creation of data structures, control flow through conditional statements and loops, input/output operations, exception handling, and text processing. The sentences show various programming constructs and operations commonly used in Java applications."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c269",
          "unique_tokens": [
            "buckets",
            "synonyms",
            "segmentsFile",
            "'",
            "start",
            "_size",
            "getXFIndex",
            "Use",
            "rec",
            "size",
            "interval",
            "dflt",
            "_lastMovedIndex",
            "min",
            "format",
            "userData",
            "pt",
            "exceptions",
            "bufferSize",
            "-",
            "0",
            "files:",
            "floatExc",
            "buffer",
            ":",
            "_value",
            "cells",
            "getColumn",
            "maxShingleSize",
            "status",
            "match",
            "weight",
            "MAX_POINTS",
            "units",
            "relativeOffset",
            ".",
            "byteToHex",
            "numBytes",
            "(R1",
            "main",
            "_firstCell",
            "affixFile",
            "other",
            "stream",
            "forwardCount",
            "_amountToMove",
            "exceeds",
            "alt",
            "impl",
            "set",
            "tracker",
            "formatIndex",
            "==",
            "fsaState",
            "from",
            "bytes",
            "offset",
            "int",
            "gridH",
            "getLength",
            "instead",
            "getEncryptionMode",
            "fontName",
            "Set",
            "fieldsData",
            "shape",
            "startOffset",
            "lexState",
            "maxWriteLen",
            "_name",
            "if",
            "label",
            "minSize",
            "bytesRemaining",
            "gets",
            "1",
            "builtInName",
            "(fileName=",
            "_input",
            "num",
            "fieldName",
            "CODEC_MAGIC",
            "n",
            ";",
            "byteCount",
            "fieldNumber",
            ".rowsumsbelw=",
            "+",
            ").",
            "_writeIndex",
            "(R2",
            "nameIndex",
            "(",
            "analyzerName",
            "&",
            "_cellType",
            "message",
            "docFreq",
            "expectedOldObjectId",
            "afterEffect",
            "getOperatorName",
            "numDocs",
            "append",
            "HexDump",
            "d",
            "replacement",
            "state",
            "getClass",
            "dictionaries",
            "bitsPerValue",
            "extBookIndex",
            "distribution",
            "minShingleSize",
            "fileName",
            "countEntries",
            "maxFacetDepth",
            "aborting",
            "MAX_ARRAY_LENGTH",
            "streamName",
            "len",
            "formatAsString",
            "dateTimeInstance2",
            "but",
            "cannot",
            "rs",
            "a",
            "ioe",
            "MurmurHash2",
            "firstSheetIndex:",
            "length;assert",
            "Integer",
            "and",
            "errorCode",
            "new,",
            "rc",
            "height",
            "mac",
            "forceUpdate",
            "version",
            "count",
            "type",
            "_operator",
            "points",
            "Version",
            "not",
            "hitIndex",
            "flag",
            "length",
            "bytesStart",
            "toHexString",
            "in",
            "sid",
            "lockFactory",
            "only",
            "commits",
            "suffix",
            "to",
            "brToString",
            "be",
            "nNames",
            "host",
            "ev.getClass().getName()",
            "id",
            "ADDINDEXES_INPUT_DIR",
            "getCellType",
            "lookupName",
            "numfonts",
            "buf",
            "}",
            ">=",
            "RamUsageEstimator",
            "code",
            "of",
            "):",
            "attribute",
            "output",
            "index",
            "columnIndex",
            "policy",
            "basicModel",
            "spec",
            "field_1_number_of_sheets",
            "i",
            "totalTermFreq",
            "distanceSquared=",
            "Long",
            "...",
            "_modeStack",
            "R1",
            "param",
            "docId",
            "getRow",
            "end",
            "classNamesLocation",
            "y",
            "codec",
            "_other",
            "xfs",
            "m",
            "=",
            "files",
            "maxMergeCount",
            "strVal",
            "cc",
            "_sfr",
            "lockName",
            "_functionName",
            "position",
            "up",
            "P_FLAGS",
            "analyzer",
            "formatQueryAsTrecTopic",
            "sheetNumber",
            "newPath",
            "[",
            "value",
            "latitude",
            "r",
            "getAlternateFormula",
            "super",
            "getWriteIndex",
            "edx",
            "e",
            "getValueText",
            "newColumn",
            ",length=",
            "path",
            "getChild",
            "maxrow",
            "trim",
            "getRuleNames",
            ".autobreaks",
            "sheetIndex",
            "toString",
            "tokens",
            "name",
            "is",
            "getStringValue",
            ",",
            "locale",
            "this",
            "DATA_SIZE",
            "]",
            "normalization",
            ".displayguts=",
            "maxVersion",
            "currentRevision",
            "(CT",
            "LATEST",
            "lambda",
            "inc",
            "i.getClass().getName()+",
            "2",
            "blockFP=",
            "\\\"",
            "leq",
            "gridW",
            "remaining",
            "minTargetSize",
            "DICTIONARY",
            "margin",
            "cell",
            "\\n",
            "nChars",
            "fields",
            "sourceFiles",
            "pEntityName",
            "firstCol",
            "bufferOffset",
            "_firstMovedIndex",
            "boost=",
            "score",
            "newDoc",
            "LEMMATIZER_MODEL",
            ">",
            "docBase",
            "newObjectId",
            "rowIndex",
            ",bytes.length=",
            "\"",
            "{",
            "asFormulaString",
            "begin",
            "bufferPos",
            "fastForward",
            "prefix",
            "pos",
            "32",
            ")",
            "return",
            "had",
            "Arrays",
            "_endIndex"
          ],
          "syntactic_label": "Variables, Methods, Operators, Keywords",
          "semantic_tags": [
            "Data Structures",
            "File Processing",
            "Exception Handling",
            "Control Flow",
            "String Manipulation"
          ],
          "description": "The tokens represent a mix of variables (e.g., buckets, synonyms, segmentsFile), methods (e.g., getXFIndex, getColumn, getLength), operators (e.g., ., ==, +, -), and keywords (e.g., if, return, new).  These are fundamental C# language elements used for data manipulation, file operations, error handling, and program control. The sentences show these tokens in action within methods, demonstrating common C# programming patterns such as method chaining (using the dot operator), conditional statements (if), exception handling (throw new IllegalArgumentException), and string manipulation (append)."
        }
      ]
    },
    "c330": {
      "encoder_cluster": {
        "id": "c330",
        "unique_tokens": [
          "_protectRecord",
          "MulBlankRecord",
          "RowRecord",
          "HyperlinkRecord",
          "TextObjectRecord",
          "ExtendedPivotTableViewFieldsRecord",
          "SharedFormulaRecord",
          "customFormatRecords",
          "nameRecord",
          "DimensionsRecord",
          "subRecStream",
          "sheetRecords",
          "int",
          "GetBSERecord",
          "FooterRecord",
          "PaneRecord",
          "externSheetRecords",
          "HCenterRecord",
          "ClearSubRecords",
          "ExtSSTRecord",
          "CFHeaderRecord",
          "OldStringRecord",
          "boundSheetRecords",
          "rowRecord",
          "LineFormatRecord",
          "CatLabRecord",
          "escherRecords",
          "ExternSheetRecord",
          "PasswordRecord",
          "GutsRecord",
          "PutRecords",
          "EscherOptRecord",
          "elseescherRecord",
          "GetBoundSheetRecords",
          "CreateSubRecord",
          "ExtendedFormatRecord",
          "BarRecord",
          "escherChildAnchorRecord",
          "StringRecord",
          "SeriesRecord",
          "NextRecord",
          "not",
          "ConvertToNumberRecord",
          ">",
          "FontRecord",
          "FnGroupCountRecord",
          "OldLabelRecord",
          "cod",
          "FindObjectRecord",
          "spgrContainer",
          "RemoveBuiltinRecord",
          "LastCellOfRowDummyRecord",
          "CreateDVRecord",
          "ObjectProtectRecord",
          "IsComponentRecord",
          "FileSharingRecord",
          "UnknownRecord",
          "FormatRecord",
          "EscherDgRecord",
          "CreateExtSSTRecord",
          "ConvertBlankRecords",
          "VisitRecord",
          "NameCommentRecord",
          "CFRuleRecord",
          "data",
          "AddListenerForAllRecords",
          "WriteAccessRecord",
          "GetOptRecord",
          "SeriesTextRecord",
          "CRNRecord",
          "ReadARecord",
          "AreaFormatRecord",
          "FormulaRecord",
          "CreateDgRecord",
          "AddBSERecord",
          "PageItemRecord",
          "AbstractEscherHolderRecord",
          "BeginRecord",
          "WSBoolRecord",
          "FilePassRecord",
          "AddEscherRecord",
          "TabIdRecord",
          "EOFRecord",
          "field_12_blipRecord",
          "newNameRecord",
          "DVALRecord",
          "RemoveFontRecord",
          "InterfaceHdrRecord",
          "PaletteRecord",
          "DumpDrawingGroupRecords",
          "ResourceRecord",
          "SelectionRecord",
          "GetCloudFormationStackRecords",
          "UseSelFSRecord",
          "MergeCellsRecord",
          "CellValueRecord",
          "escherBSERecords",
          "MulRKRecord",
          "commentRecords",
          "CfRuleRecord",
          "_passwordRecord",
          "PrintSetupRecord",
          "DataItemRecord",
          "WindowOneRecord",
          "DrawingSelectionRecord",
          "extNameRecord",
          "objRecord",
          "AddRecords",
          "BOFRecord",
          "ChartEndBlockRecord",
          "EscherBlipRecord",
          "childRecord",
          "LegendRecord",
          "BackupRecord",
          "cellRecord",
          ")",
          "InfoSubRecord",
          "_spgrRecord",
          "DataLabelExtensionRecord",
          "WindowTwoRecord",
          "AddNewSheetRecord",
          "_childRecords",
          "RemoveChildRecord",
          "GroupMarkerSubRecord",
          "FtCfSubRecord",
          "CalcModeRecord",
          "MissingCellDummyRecord",
          "GetNameCommentRecord",
          "AddValueRecord",
          "ObjectLinkRecord",
          "LinkSharedFormulaRecord",
          "EscherTextboxRecord",
          "StartRecord",
          "TableStylesRecord",
          "GetExternSheetRecords",
          "GetSpecificBuiltinRecord",
          "ListRecords",
          "SeriesLabelsRecord",
          "ch",
          "AddMergeCellsRecord",
          "SeriesChartGroupIndexRecord",
          "ProcessContinueRecord",
          "TopMarginRecord",
          "ChartRecord",
          "ArrayRecord",
          "=",
          "origNameRecord",
          "EscherSpRecord",
          "sfr",
          "wbRecords",
          "spContainer",
          "UnitsRecord",
          "_scenarioProtectRecord",
          "ruleRecord",
          "SeriesToChartGroupRecord",
          "PrintGridlinesRecord",
          "StyleRecord",
          "ObjRecord",
          "ConvertToEscherRecords",
          "SSTRecord",
          "CRNCountRecord",
          "IsBeginRecord",
          "xfRecords",
          "_note",
          "DatRecord",
          "textObjectRecord",
          "SubRecord",
          "PasswordRev4Record",
          "ConvertRKRecords",
          "EndSubRecord",
          "SupBookRecord",
          "DeltaRecord",
          "DefaultColWidthRecord",
          "ChartFormatRecord",
          "newRecord",
          "RemoveExFormatRecord",
          "EscherRecords",
          "ExternalNameRecord",
          "MissingRowDummyRecord",
          "GridsetRecord",
          "UpdateRecords",
          "EscherBSERecord",
          "IsRowBlockRecord",
          "commentRecord",
          "GetPasswordRecord",
          "PlotAreaRecord",
          "WindowProtectRecord",
          "EscherChildAnchorRecord",
          "r",
          "IterationRecord",
          "_unknownRecords",
          "RefModeRecord",
          "GetRecords",
          "TableRecord",
          "GetEscherRecord",
          "CodepageRecord",
          "GetExternalBookRecord",
          "DrawingRecord",
          "ClearEscherRecords",
          "VisitContainedRecords",
          "ReadNextRecord",
          "LabelSSTRecord",
          ",",
          "ViewDefinitionRecord",
          "VCenterRecord",
          "SeriesIndexRecord",
          "AddSubRecord",
          "optRecord",
          ".",
          "AreaRecord",
          "AxisParentRecord",
          "escherRecord",
          "ProtectionRev4Record",
          "BottomMarginRecord",
          "Append",
          "CreateRecord",
          "LabelRecord",
          "RightMarginRecord",
          "SeriesListRecord",
          "IsContainerRecord",
          "AddChildRecord",
          "FrameRecord",
          "GetNameRecord",
          "FeatHdrRecord",
          "ChildRecords",
          "HeaderFooterRecord",
          "ValueRangeRecord",
          "ContinueRecord",
          "dvRecord",
          "BoolErrRecord",
          "GetSSTRecord",
          "ViewFieldsRecord",
          "_externalBookRecord",
          "shortRecord",
          "externalRecord",
          "DrawingGroupRecord",
          "NameRecord",
          ";",
          "(",
          "LeftMarginRecord",
          "SCLRecord",
          "ProtectRecord",
          "subRecord",
          "_rowRecords",
          "PrintHeadersRecord",
          "BlankRecord",
          "HeaderRecord",
          "PutRecord",
          "SaveRecalcRecord",
          "ViewSourceRecord",
          "PageBreakRecord",
          "+",
          "HideObjRecord",
          "blip",
          "CalcCountRecord",
          "BoundSheetRecord",
          "GetNext",
          "TickRecord",
          "EscherRecord",
          "EndRecord",
          "HasNextRecord",
          "DataFormatRecord",
          "_objectProtectRecord",
          "IndexRecord",
          "EscherClientAnchorRecord",
          "DefaultRowHeightRecord",
          "ColumnInfoRecord",
          "RECORD_ID",
          "EscherContainerRecord",
          "FontBasisRecord",
          "CountryRecord",
          "nFullMergedCellsRecords",
          "RefSubRecord",
          "MMSRecord",
          "supbook",
          "NumberRecord",
          "FtPioGrbitSubRecord",
          "DBCellRecord",
          "IsTerminating",
          "BookBoolRecord",
          "_externSheetRecord",
          "DConRefRecord",
          "GetRawRecord",
          "RecalcIdRecord",
          "GetExportSnapshotRecords",
          "childRecords",
          "escherClientAnchorRecord",
          "NumberFormatIndexRecord",
          "TextRecord",
          "GetNextUnreadRecord",
          "ScenarioProtectRecord",
          "OldFormulaRecord",
          "CreateSingleRecord",
          "_externalNameRecords",
          "EmbeddedObjectRefSubRecord",
          "EscherDggRecord",
          "NoteRecord",
          "RKRecord",
          "[",
          "BRAIRecord",
          "DVRecord",
          "UncalcedRecord"
        ],
        "syntactic_label": "Record identifiers and variables",
        "semantic_tags": [
          "Data Structures",
          "Record Management",
          "Spreadsheet Data",
          "File I/O",
          "Object Serialization"
        ],
        "description": "The tokens represent identifiers for various record types within a spreadsheet file format (likely Excel).  The code snippets show the creation, reading, writing, and manipulation of these records.  The `int`, `short`, and `byte` types indicate data sizes and types used in the file format. The semantic tags reflect the core operations: managing spreadsheet data, reading/writing records from/to streams, and handling the structure of the file."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c425",
          "unique_tokens": [
            "addEscherRecord",
            "EscherOptRecord",
            "createDVRecord",
            "data",
            "FtPioGrbitSubRecord",
            "HCenterRecord",
            "remains:",
            "CountryRecord",
            "ProtectRecord",
            "DVALRecord",
            "GridsetRecord",
            "NumberFormatIndexRecord",
            "extNameRecord",
            "CatLabRecord",
            "SeriesChartGroupIndexRecord",
            "FileSharingRecord",
            "removeChildRecord",
            ":",
            "IterationRecord",
            "_protectRecord",
            "MulBlankRecord",
            "BOFRecord",
            "externalRecord",
            "ViewDefinitionRecord",
            "ViewSourceRecord",
            "UseSelFSRecord",
            "SubRecord",
            "SupBookRecord",
            "NoteRecord",
            "getOptRecord",
            "SeriesLabelsRecord",
            "LbsDataSubRecord",
            ".",
            "removeFontRecord",
            "TickRecord",
            "FontRecord",
            "IndexRecord",
            "PasswordRev4Record",
            "MulRKRecord",
            "addBSERecord",
            "FontBasisRecord",
            "supbook",
            "PrintHeadersRecord",
            "BarRecord",
            "EscherBlipRecord",
            "LegendRecord",
            "addValueRecord",
            "VCenterRecord",
            "removeBuiltinRecord",
            "addNewSheetRecord",
            "AbstractEscherHolderRecord",
            "NumberRecord",
            "_objectProtectRecord",
            "readNextRecord",
            "EscherSpRecord",
            "dvRecord",
            "RefSubRecord",
            "optRecord",
            "BoundSheetRecord",
            "getSpecificBuiltinRecord",
            "RightMarginRecord",
            "OldStringRecord",
            "BackupRecord",
            "ChartRecord",
            "isContainerRecord",
            "InterfaceHdrRecord",
            "NameRecord",
            "textObjectRecord",
            "createExtSSTRecord",
            "LineFormatRecord",
            "commentRecord",
            "OldFormulaRecord",
            "RecalcIdRecord",
            "isComponentRecord",
            "getRawRecord",
            "getEscherRecord",
            "WSBoolRecord",
            "DataItemRecord",
            "objRecord",
            "LabelSSTRecord",
            "linkSharedFormulaRecord",
            "CalcCountRecord",
            "ProtectionRev4Record",
            "FeatHdrRecord",
            "ch",
            "ArrayRecord",
            ";",
            "createDgRecord",
            "ruleRecord",
            "nextRecord",
            "+",
            "CFRuleRecord",
            "PrintGridlinesRecord",
            "GroupMarkerSubRecord",
            "visitRecord",
            "PaletteRecord",
            "(",
            "GutsRecord",
            "TableStylesRecord",
            "CodepageRecord",
            "BlankRecord",
            "CFHeaderRecord",
            "AreaFormatRecord",
            "putRecord",
            "ExtendedFormatRecord",
            "cod",
            "CalcModeRecord",
            "readARecord",
            "EndSubRecord",
            "DatRecord",
            "LastCellOfRowDummyRecord",
            "_externSheetRecord",
            "WriteAccessRecord",
            "createRecord",
            "PaneRecord",
            "ObjectProtectRecord",
            "ContinueRecord",
            "DeltaRecord",
            "getPasswordRecord",
            "EscherChildAnchorRecord",
            "ExtSSTRecord",
            "shortRecord",
            "DefaultColWidthRecord",
            "ExtendedPivotTableViewFieldsRecord",
            "findObjectRecord",
            "LeftMarginRecord",
            "newRecord",
            "cmo",
            "PageBreakRecord",
            "UnknownRecord",
            "getNameRecord",
            "PrintSetupRecord",
            "not",
            "SeriesRecord",
            "TabIdRecord",
            "RKRecord",
            "DVRecord",
            "FilePassRecord",
            "nameRecord",
            "getCellValueRecord",
            "PageItemRecord",
            "EscherContainerRecord",
            "DrawingSelectionRecord",
            "EOFRecord",
            "WindowProtectRecord",
            "FeatRecord",
            "DefaultRowHeightRecord",
            "DimensionsRecord",
            "SelectionRecord",
            "SeriesToChartGroupRecord",
            "spContainer",
            "DrawingRecord",
            "SSTRecord",
            "HeaderRecord",
            "MissingRowDummyRecord",
            "field_12_blipRecord",
            "CFHeader12Record",
            "AxisParentRecord",
            "addMergeCellsRecord",
            "newNameRecord",
            "_passwordRecord",
            "PasswordRecord",
            "hasNextRecord",
            "FormulaRecord",
            "createSingleRecord",
            "HyperlinkRecord",
            "getBSERecord",
            "shouldSkipEncryptionOnCurrentRecord",
            "_scenarioProtectRecord",
            "NameCommentRecord",
            "StyleRecord",
            "AreaRecord",
            "SeriesIndexRecord",
            "TextObjectRecord",
            "OldLabelRecord",
            "removeExFormatRecord",
            "EscherTextboxRecord",
            "TableRecord",
            "DataFormatRecord",
            "EscherDggRecord",
            "escherRecord",
            "SharedFormulaRecord",
            "as",
            "FtCfSubRecord",
            "TopMarginRecord",
            "DataLabelExtensionRecord",
            "getRowRecord",
            "EscherDgRecord",
            "HeaderFooterRecord",
            "FnGroupCountRecord",
            ")",
            "=",
            "ViewFieldsRecord",
            "WindowOneRecord",
            "ColumnInfoRecord",
            "EscherClientAnchorRecord",
            "SeriesListRecord",
            "DBCellRecord",
            "processContinueRecord",
            "RefModeRecord",
            "ExternSheetRecord",
            "ObjRecord",
            "subRecord",
            "origNameRecord",
            "[",
            "UnknownSubRecord",
            "isNeverEncryptedRecord",
            "SCLRecord",
            "EndRecord",
            "rowRecord",
            "DrawingGroupRecord",
            "isRowBlockRecord",
            "BottomMarginRecord",
            "has",
            "getNameCommentRecord",
            "StringRecord",
            "CFRule12Record",
            "_externalBookRecord",
            "SeriesTextRecord",
            "MergeCellsRecord",
            "RowRecord",
            "getExternalBookRecord",
            "BoolErrRecord",
            "DConRefRecord",
            "BeginRecord",
            "name",
            "ChartEndBlockRecord",
            ",",
            "HideObjRecord",
            "FooterRecord",
            "SaveRecalcRecord",
            "isBeginRecord",
            "PlotAreaRecord",
            "executePutRecord",
            "LinkedDataRecord",
            "convertToNumberRecord",
            "InfoSubRecord",
            "CRNRecord",
            "getCfRuleRecord",
            "FrameRecord",
            "MMSRecord",
            "FormatRecord",
            "escherClientAnchorRecord",
            "MissingCellDummyRecord",
            "CRNCountRecord",
            "ExternalNameRecord",
            "EscherBSERecord",
            "getSSTRecord",
            "ResourceRecord",
            "BookBoolRecord",
            "addSubRecord",
            ">",
            "childRecord",
            "_spgrRecord",
            "ChartFormatRecord",
            "LabelRecord",
            "EmbeddedObjectRefSubRecord",
            "ObjectLinkRecord",
            "escherChildAnchorRecord",
            "TextRecord",
            "ValueRangeRecord",
            "WindowTwoRecord",
            "ScenarioProtectRecord",
            "UnitsRecord",
            "addChildRecord",
            "UncalcedRecord",
            "EscherRecord",
            "getNextUnreadRecord"
          ],
          "syntactic_label": "Record identifiers, methods, and operators",
          "semantic_tags": [
            "Record Management",
            "Data Structures",
            "File I/O",
            "Object Serialization",
            "Data Processing"
          ],
          "description": "The tokens represent identifiers for various record types in a C# library, likely related to a file format (e.g., Excel).  Methods like 'addEscherRecord', 'removeChildRecord', 'getEscherRecord', etc., manage these records. Operators like '.' (dot operator) are used for method calls and member access, while '+' might be used for data concatenation.  The ';' indicates statement termination. Overall, the code appears to handle the reading, writing, and manipulation of structured data within a file."
        }
      ]
    },
    "c383": {
      "encoder_cluster": {
        "id": "c383",
        "unique_tokens": [
          "existing",
          "prev",
          "currently",
          ";",
          "sb",
          "old",
          "+",
          "<=",
          "original",
          ")",
          "7",
          "last",
          "current",
          "}",
          ",",
          "string",
          ".",
          "At",
          "==",
          "previous",
          "="
        ],
        "syntactic_label": "Variables, Operators, and Keywords",
        "semantic_tags": [
          "Iteration and Control Flow",
          "Data Structures",
          "Array Manipulation",
          "Exception Handling",
          "Object Manipulation"
        ],
        "description": "The tokens represent a mix of variables (e.g., existing, prev, currently, sb, old, original, last, current), operators (+, <=, ==, =), keywords (e.g., if, else, return, while, for, int, new, throw, public, static, virtual, override), and special characters (; , . ).  They are used in various Java methods to perform operations such as array copying (copyOfRange), string manipulation (Append), list traversal (previous, next), and exception handling (throw). The semantic tags reflect the common functionalities observed in the provided code snippets."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c188",
          "unique_tokens": [
            "first",
            "seqnum",
            "<",
            "previous",
            "boost",
            "_next",
            ";",
            "+",
            "}",
            "(",
            ",",
            "prev",
            ".",
            "sb",
            "tokArgs",
            "itr",
            "/",
            "original",
            "endOffset",
            "last",
            "==",
            "termsOffsets",
            "=",
            "\"",
            "next",
            "raw",
            "startOffset",
            ")",
            "current"
          ],
          "syntactic_label": "Variables, Objects, Methods, Operators, and Literals",
          "semantic_tags": [
            "Iteration and Traversal",
            "Data Structures",
            "Object Manipulation",
            "Control Flow",
            "Utility Functions"
          ],
          "description": "The tokens represent a mix of data structures (List, ArrayList, Iterator, etc.), variables (first, seqnum, previous, boost, etc.), methods (next, previous, getToken, etc.), operators (., +, ==, <, etc.), and literals ('\\n', '\"', etc.).  These are fundamental elements in C# programming, used extensively for various tasks such as iterating through collections, manipulating objects, controlling program flow, and performing utility operations. The context sentences show these tokens in action within different methods, suggesting a focus on data processing and algorithm implementation."
        }
      ]
    },
    "c388": {
      "encoder_cluster": {
        "id": "c388",
        "unique_tokens": [
          "xmin",
          "field_2_first_column_index",
          "pref",
          "64",
          "return",
          "but",
          "5",
          "{",
          "bufferSize",
          "1024.0",
          ":",
          "+=",
          "previousDoc",
          ";",
          "(",
          "2.0",
          "int",
          "1024",
          "read_1",
          "LOAD_FACTOR",
          "180",
          "index",
          "mKeyProgressIncrement",
          "+",
          "pos",
          "i",
          "BYTE_BLOCK_SIZE",
          "part1",
          "var",
          "n",
          "512",
          "4",
          "20",
          "frac",
          "ByteBuffer",
          "undefined",
          "skipped",
          "0",
          ")",
          "\"",
          "throw",
          "field_1_number_crn_records",
          "verticalPixelsPerPoint",
          "must",
          "/",
          "count",
          "num",
          "sampledDocs",
          "}",
          "3",
          "from",
          ",",
          "k",
          "2",
          "don't",
          "Time",
          "inc",
          "StatsLib",
          "range",
          ".",
          "ymin",
          "-",
          "1023",
          "expAdj",
          "NANOS_PER_SEC",
          "bitsPerValue",
          "expected",
          "&&",
          "1",
          "Lexer",
          "startIndex"
        ],
        "syntactic_label": "Unknown",
        "semantic_tags": [
          "Unknown"
        ],
        "description": "Failed to classify due to processing error."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c32",
          "unique_tokens": [
            "nextIndex",
            "NANOS_PER_SEC",
            "'",
            "start",
            "180",
            "bPtr",
            "1",
            "step",
            "num",
            "undefined",
            "n",
            ";",
            "4",
            "Automaton",
            "+",
            ">=",
            "xmin",
            "}",
            "expAdj",
            "(",
            "-",
            "+=",
            "info",
            "skipped",
            "subRecStream",
            "index",
            "range",
            "else",
            "pos",
            ",",
            "don't",
            "rpt:",
            "i",
            "2.0",
            "]",
            "available",
            "frac",
            "bitsPerValue",
            "startIndex",
            ".",
            "expected",
            "-=",
            "c2",
            "2",
            "inc",
            "/",
            "but",
            "field_2_first_column_index",
            "ByteBuffer",
            "end",
            "nChars",
            "5",
            "ymin",
            "64",
            "bytes",
            "\"",
            "must",
            "{",
            "count",
            "OBJECT_ID_LENGTH",
            "1023",
            "throw",
            "field_1_number_crn_records",
            "3",
            "1024",
            "length",
            ")",
            "block",
            "return",
            "if",
            "agg"
          ],
          "syntactic_label": "C# Tokens and Symbols",
          "semantic_tags": [
            "Control Flow",
            "Data Structures",
            "Exception Handling",
            "File I/O",
            "Mathematical Operations"
          ],
          "description": "The tokens represent a wide range of C# language features.  Keywords like `if`, `else`, and `return` control program flow. Identifiers such as `nextIndex`, `available`, and `writeContinue` suggest methods or variables related to data structures and algorithms.  The presence of `throw` indicates exception handling.  `ByteBuffer`, `InputStream`, and `OutputStream` point to file I/O operations.  Operators like `+`, `-`, `/`, and mathematical functions reveal mathematical computations within the code."
        }
      ]
    },
    "c417": {
      "encoder_cluster": {
        "id": "c417",
        "unique_tokens": [
          "UpperCaseFilter",
          "PathSuffixFilter",
          "OffsetLimitTokenFilter",
          "ICUNormalizer2CharFilter",
          "QueryWrapperFilter",
          "SynonymFilter",
          "CommitterRevFilter",
          "BrazilianStemFilter",
          "TreeFilter",
          "SwedishLightStemFilter",
          "ItalianLightStemFilter",
          "ICUNormalizer2Filter",
          "ApostropheFilter",
          "EnglishMinimalStemFilter",
          "TruncateTokenFilter",
          "HyphenationCompoundWordTokenFilter",
          "AndRevFilter",
          "JapaneseIterationMarkCharFilter",
          "MaxCountRevFilter",
          "HungarianLightStemFilter",
          "GetPathFilter",
          "OrTreeFilter",
          "NotTreeFilter",
          "RevFilter",
          "PatternKeywordMarkerFilter",
          "NGramTokenFilter",
          "PhoneticFilter",
          "StemmerOverrideFilter",
          "CzechStemFilter",
          "DelimitedPayloadTokenFilter",
          "DoubleMetaphoneFilter",
          "FileFilter",
          "AndTreeFilter",
          "PatternCaptureGroupTokenFilter",
          "MappingCharFilter",
          "FollowFilter",
          "stopFilter",
          "ICUFoldingFilter",
          "CharFilter",
          "JapaneseReadingFormFilter",
          "BulgarianStemFilter",
          "CloneFilter",
          "SoraniNormalizationFilter",
          "PatternReplaceFilter",
          "CreateReceiptFilter",
          "KeywordRepeatFilter",
          "ASCIIFoldingFilter",
          "ArabicStemFilter",
          "OpenNLPChunkerFilter",
          "StopFilter",
          "MessageRevFilter",
          "PersianNormalizationFilter",
          "SubStringRevFilter",
          "DeleteFilter",
          "GermanNormalizationFilter",
          "CreateTrafficMirrorFilter",
          "TypeTokenFilter",
          "HindiStemFilter",
          "CommonGramsFilter",
          "NorwegianMinimalStemFilter",
          "=",
          "GreekLowerCaseFilter",
          "IndonesianStemFilter",
          "RevFlagFilter",
          "OrRevFilter",
          "GalicianStemFilter",
          "UpdateFilter",
          "TokenOffsetPayloadTokenFilter",
          "ArabicNormalizationFilter",
          "CJKWidthFilter",
          "NorwegianLightStemFilter",
          "WordDelimiterFilter",
          "SetKeywordMarkerFilter",
          "ElisionFilter",
          "PorterStemFilter",
          "SpanishLightStemFilter",
          "FrenchMinimalStemFilter",
          "IrishLowerCaseFilter",
          "JapanesePartOfSpeechStopFilter",
          "CapitalizationFilter",
          "DictionaryCompoundWordTokenFilter",
          "pathFilter",
          ",",
          "OpenNLPPOSFilter",
          "LimitTokenPositionFilter",
          ".",
          "SnowballFilter",
          "ICUTransformFilter",
          "GreekStemFilter",
          "FrenchLightStemFilter",
          "CJKBigramFilter",
          "ShingleFilter",
          "ANY_DIFF",
          "GermanStemFilter",
          "SkipRevFilter",
          "LimitTokenCountFilter",
          "KeepWordFilter",
          "PortugueseMinimalStemFilter",
          "SetTreeFilter",
          "LengthFilter",
          "NumericPayloadTokenFilter",
          "OpenNLPLemmatizerFilter",
          "DEFAULT_MAX_TOKEN_LENGTH",
          "ScandinavianNormalizationFilter",
          "PathFilterGroup",
          "FinnishLightStemFilter",
          "GermanLightStemFilter",
          ";",
          "updateDropDownForFilter",
          "JapaneseKatakanaStemFilter",
          "PatternReplaceCharFilter",
          "charFilter",
          "CodepointCountFilter",
          "newFilter",
          "DEFAULT_MAX_WORD_COUNT",
          "StempelFilter",
          "GetFilter",
          "HunspellStemFilter",
          "ClassicFilter",
          "ValueSourceFilter",
          "BeiderMorseFilter",
          "IndexDiffFilter",
          "treeFilter",
          "SetRevFilter",
          "DeleteTrafficMirrorFilter",
          "EdgeNGramTokenFilter",
          "KStemFilter",
          "SetWrapIfNotCachingTokenFilter",
          "ScandinavianFoldingFilter",
          "IndicNormalizationFilter",
          "FilenameFilter",
          "HindiNormalizationFilter",
          "JapaneseBaseFormFilter",
          "Create",
          "SetPathFilter",
          "PathFilter",
          "NotRevFilter",
          "AuthorRevFilter",
          "HTMLStripCharFilter",
          "TypeAsPayloadTokenFilter",
          "LowerCaseFilter",
          "TurkishLowerCaseFilter",
          "DeleteReceiptFilter"
        ],
        "syntactic_label": "Filter Classes and Objects",
        "semantic_tags": [
          "Text Processing",
          "Data Filtering",
          "Tokenization",
          "Version Control",
          "Lucene"
        ],
        "description": "The tokens represent a collection of filter classes and objects primarily used for text processing and data filtering within the context of Lucene and version control systems like Git.  They modify or filter token streams (sequences of words or tokens) based on various criteria, such as stemming, normalization, pattern matching, and more.  The '=' operator is used for assignment, and the ',' is a list separator. The '.' operator is used for method invocation. The ';' is used as a statement terminator."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c215",
          "unique_tokens": [
            "HindiStemFilter",
            "CJKWidthFilter",
            "cloneFilter",
            "FileFilter",
            "StopFilter",
            "createReceiptFilter",
            "KeepWordFilter",
            "HTMLStripCharFilter",
            "PorterStemFilter",
            "executeListReceiptFilters",
            "NumericPayloadTokenFilter",
            "CJKBigramFilter",
            ".",
            "SoraniNormalizationFilter",
            "IrishLowerCaseFilter",
            "ASCIIFoldingFilter",
            "JapaneseReadingFormFilter",
            "OpenNLPPOSFilter",
            "LowerCaseFilter",
            "SetKeywordMarkerFilter",
            "ShingleFilter",
            "create",
            "PathFilter",
            "NorwegianLightStemFilter",
            "executeUpdateFilter",
            "updateFilter",
            "parentsFilter",
            "SpanishLightStemFilter",
            "deleteReceiptFilter",
            "TreeFilter",
            "HunspellStemFilter",
            "PortugueseMinimalStemFilter",
            "CodepointCountFilter",
            "PatternReplaceFilter",
            "EdgeNGramTokenFilter",
            "LimitTokenPositionFilter",
            "FollowFilter",
            "NGramTokenFilter",
            "ICUNormalizer2CharFilter",
            "ItalianLightStemFilter",
            "setRevFilter",
            "!=",
            "SwedishLightStemFilter",
            "ICUTransformFilter",
            "BrazilianStemFilter",
            ";",
            "LimitTokenCountFilter",
            "newFilter",
            "(",
            "StemmerOverrideFilter",
            "executeDescribeTrafficMirrorFilters",
            "createTrafficMirrorFilter",
            "stopFilter",
            "PersianNormalizationFilter",
            "getPathFilter",
            "OffsetLimitTokenFilter",
            "ScandinavianNormalizationFilter",
            "TokenFilter",
            "ICUFoldingFilter",
            "setPathFilter",
            "GalicianStemFilter",
            "SnowballFilter",
            "JapaneseBaseFormFilter",
            "TypeTokenFilter",
            "subfilters",
            "FrenchLightStemFilter",
            "IndonesianStemFilter",
            "DoubleMetaphoneFilter",
            "updateDropDownForFilter",
            "KeywordRepeatFilter",
            "executeCreateReceiptFilter",
            "describeTrafficMirrorFilters",
            "CharFilter",
            "listReceiptFilters",
            "GermanNormalizationFilter",
            "AndRevFilter",
            "JapaneseIterationMarkCharFilter",
            "SynonymFilter",
            "excludeTreeFilters",
            "StempelFilter",
            "TokenOffsetPayloadTokenFilter",
            "BeiderMorseFilter",
            "AndTreeFilter",
            "BulgarianStemFilter",
            "KStemFilter",
            "ClassicFilter",
            "CzechStemFilter",
            "i",
            "executeDeleteTrafficMirrorFilter",
            "HungarianLightStemFilter",
            "NotRevFilter",
            "ArabicStemFilter",
            "TurkishLowerCaseFilter",
            "setWrapIfNotCachingTokenFilter",
            "HyphenationCompoundWordTokenFilter",
            "deleteFilter",
            "ICUNormalizer2Filter",
            "IndicNormalizationFilter",
            "JapanesePartOfSpeechStopFilter",
            "MaxCountRevFilter",
            "ElisionFilter",
            "ScandinavianFoldingFilter",
            "=",
            "DictionaryCompoundWordTokenFilter",
            "executeCreateTrafficMirrorFilter",
            "RevFilter",
            "setTreeFilter",
            "HindiNormalizationFilter",
            "FilenameFilter",
            "FinnishLightStemFilter",
            "EnglishMinimalStemFilter",
            "[",
            "CapitalizationFilter",
            "MappingCharFilter",
            "PatternKeywordMarkerFilter",
            "ApostropheFilter",
            "SkipRevFilter",
            "pathFilters",
            "PhoneticFilter",
            "ArabicNormalizationFilter",
            "IndexDiffFilter",
            "PatternCaptureGroupTokenFilter",
            "executeListFilters",
            "deleteTrafficMirrorFilter",
            ",",
            "SubStringRevFilter",
            "GermanStemFilter",
            "CommonGramsFilter",
            "Filter",
            "OpenNLPLemmatizerFilter",
            "charFilter",
            "NorwegianMinimalStemFilter",
            "JapaneseKatakanaStemFilter",
            "OpenNLPChunkerFilter",
            "NotTreeFilter",
            "executeDeleteFilter",
            "GreekLowerCaseFilter",
            "GermanLightStemFilter",
            "executeGetFilter",
            "TruncateTokenFilter",
            "listFilters",
            "DelimitedPayloadTokenFilter",
            "matchFilter",
            "pathFilter",
            "TypeAsPayloadTokenFilter",
            "\"",
            "UpperCaseFilter",
            "FrenchMinimalStemFilter",
            "treeFilter",
            "filter",
            "GreekStemFilter",
            "PathSuffixFilter",
            "executeDeleteReceiptFilter",
            ")",
            "LengthFilter",
            "PatternReplaceCharFilter"
          ],
          "syntactic_label": "TokenFilters and CharFilters",
          "semantic_tags": [
            "Text Processing",
            "Tokenization",
            "Filtering",
            "Stemming",
            "Normalization"
          ],
          "description": "The tokens represent a collection of C# classes that extend the TokenFilter and CharFilter classes from the Lucene.Net library. These classes are used for various text processing tasks such as tokenization, stemming, normalization, and filtering.  They are chained together to perform a sequence of operations on a stream of tokens.  The methods create and clone are common to many of these filters, indicating a factory pattern for filter creation and copying.  The various filter types (e.g., HindiStemFilter, CJKWidthFilter, etc.) indicate diverse language support and processing capabilities. The use of the dot operator (.) is for method invocation and object access, while the special characters such as '(' and ')' are used for method parameters and the '!=' and '=' operators are used for comparisons and assignments."
        }
      ]
    },
    "c437": {
      "encoder_cluster": {
        "id": "c437",
        "unique_tokens": [
          ")",
          "Term",
          "Equals",
          "(",
          "typeof"
        ],
        "syntactic_label": "Operators and Keywords",
        "semantic_tags": [
          "Equality Comparison",
          "Type Checking",
          "Conditional Logic",
          "Object Instantiation",
          "Method Invocation"
        ],
        "description": "These tokens represent fundamental Java operators and keywords used for comparisons, type checking, conditional execution, object creation, and method calls.  The `Equals` token signifies equality checks, often used in `if` statements (conditional logic). The `typeof` operator checks the type of an object. Parentheses `(` and `)` are used for grouping and method calls. The `Term` token likely represents a class or object, and its usage within the `Equals` method suggests object comparison."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c340",
          "unique_tokens": [
            "Term",
            "other",
            "getValue",
            "cell",
            ")",
            "equals",
            "("
          ],
          "syntactic_label": "Method parameters, local variables, method calls, Object, Dot operator, Equality operators",
          "semantic_tags": [
            "Object comparison",
            "Data processing",
            "Input/Output operations",
            "String manipulation",
            "Conditional logic"
          ],
          "description": "The tokens represent various elements in C# methods.  'Term', 'other', and 'cell' appear to be object names or variables. 'getValue' suggests a method call to retrieve a value.  'equals' is used for object comparison. '(' and ')' are parentheses for method calls and conditional statements. The code snippets show various operations including string manipulation using StringBuilder, object comparisons using equals(), and conditional logic using if statements.  The overall purpose seems to be data processing and object manipulation."
        }
      ]
    },
    "c446": {
      "encoder_cluster": {
        "id": "c446",
        "unique_tokens": [
          "crRowInput",
          "cr",
          ")",
          "\"",
          "Append",
          "buffer",
          "(",
          ",",
          "field_10_colInputCol"
        ],
        "syntactic_label": "Object, Variable, Method, Opening Parenthesis, Closing Parenthesis, Comma, String Literal, Method Call",
        "semantic_tags": [
          "API Request Generation",
          "String Manipulation",
          "Data Representation",
          "Object Instantiation",
          "URI Construction"
        ],
        "description": "The tokens represent various elements involved in constructing and representing API requests.  'cr' seems to be an object or variable frequently used, possibly representing a context or configuration.  'Append' is a method call used for string manipulation, building up the representation of the API request.  Parentheses and commas are syntactic elements for method calls and object instantiation.  'buffer' is a variable likely used to accumulate the string representation of the API request.  'field_10_colInputCol' appears to be a variable holding data for the API request. The overall code snippet focuses on generating API requests, likely for a RESTful API, by constructing URIs and other request parameters."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c11",
          "unique_tokens": [
            "Add-In",
            "sb",
            "k",
            "_sheetIndex",
            "\"",
            "buffer",
            ",",
            "__",
            "append",
            "\\n",
            "&",
            "tracker",
            ";",
            "_",
            ")",
            ".",
            "else",
            "("
          ],
          "syntactic_label": "C# Tokens and Syntax",
          "semantic_tags": [
            "String Manipulation",
            "Object Representation",
            "Debugging",
            "File System Operations",
            "Data Structures"
          ],
          "description": "The tokens represent a mix of C# language constructs, including identifiers (sb, k, _sheetIndex, tracker), operators (., +, =, ==, !=, <, >), literals (\", \n), keywords (if, else, return), and special characters ((, ), [, ], {, }).  They are used in various contexts, such as creating string representations of objects (using StringBuilder), conditional logic (if-else statements), file system operations (Directory.listAll), and data structure manipulation.  The semantic tags reflect the diverse functionalities present in the code snippets."
        }
      ]
    },
    "c463": {
      "encoder_cluster": {
        "id": "c463",
        "unique_tokens": [
          "GetLineText",
          "ToString",
          "tagger",
          "null",
          ";",
          "(",
          "bsr",
          "m_min",
          "0",
          "in",
          ")",
          "1Hr",
          "r",
          "\"",
          "new",
          "_unmappableErrors",
          "}",
          "\\r",
          "_malformedErrors",
          ",",
          ".",
          "ryr",
          "this",
          "tfr",
          "Append",
          "cvr",
          "m_suffix",
          "[",
          "message",
          "="
        ],
        "syntactic_label": "Variables, Objects, Methods, Operators, and Literals",
        "semantic_tags": [
          "String Manipulation",
          "Object Cloning",
          "Data Structures",
          "Input/Output",
          "Error Handling"
        ],
        "description": "The tokens represent a mix of data types, objects (like StringBuilder), methods (like Append, ToString), operators (like ., =, ==), and literals (like 0, null, \r).  They are used in various ways, including string manipulation (EscapeWhitespace, Quote, ToString methods), object creation and cloning (new PackIndex.MutableEntry, new StringBuilder), working with data structures (lists, arrays, iterators), handling input/output (TextReader), and error handling (exception handling). The overall code snippets demonstrate common Java programming patterns and practices."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c52",
          "unique_tokens": [
            "r",
            "'",
            "<",
            "[/PRINTHEADERS]",
            ".isxvi",
            "crColInput",
            "shortToHex",
            "tfr",
            "getSheetname",
            "atn",
            "n",
            ";",
            "%n",
            ".bgcoloridx=",
            "+",
            "0",
            "sheetname",
            "}",
            "[/STYLE]",
            "(",
            "k",
            "[/SERIESTEXT]",
            "toString",
            "message",
            "buffer",
            "numPoints",
            ",",
            ":",
            "cvr",
            "append",
            "add",
            "]",
            "minDocFreq",
            "isBorder",
            "tagger",
            "HexDump",
            "i",
            "\\r",
            ".",
            "getLineText",
            "csn",
            "sb",
            "k2",
            "(n",
            "\\t",
            "ryr",
            "p",
            "\\n",
            "serializedAtn",
            "tfn",
            "bgpAsn",
            "for",
            ">",
            ".grbitSub",
            "1Hr",
            "Integer",
            ".vertPos",
            "==",
            "substring",
            "=",
            "\"",
            "{",
            "bsr",
            "getActiveCellCol",
            "prefix",
            "length",
            ")",
            "[",
            "if",
            "in"
          ],
          "syntactic_label": "C# Tokens and Symbols",
          "semantic_tags": [
            "String Manipulation",
            "Data Structures",
            "Control Flow",
            "Object Serialization",
            "Exception Handling"
          ],
          "description": "The tokens represent a wide range of C# language elements.  Keywords like \"if\", \"for\", operators like \".\", \"+\", \"==\", symbols like \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and identifiers such as \"StringBuilder\", \"HexDump\", and various method calls (\"append\", \"toString\", etc.) are used. These elements are fundamental to C# programming, enabling the construction of complex data structures, control flow mechanisms, and object serialization for data representation.  Exception handling is also present, as indicated by the \"throws RecognitionException\" clause. The code snippets appear to be related to the construction and manipulation of string representations of data, possibly for logging, debugging, or data exchange purposes."
        }
      ]
    },
    "c465": {
      "encoder_cluster": {
        "id": "c465",
        "unique_tokens": [
          "StringBuilder",
          "ToString",
          "AppendFormat",
          ";",
          "(",
          "EXHAUST",
          "int",
          "calibrateSizeByDeletes=",
          "bottom",
          "sb",
          "name=",
          "_idEdit",
          ")",
          "\"",
          "newObjectId",
          "}",
          ",",
          "ptg",
          ".",
          "!",
          "]",
          "sheet=",
          "Append",
          "originalText",
          "assign",
          "oldObjectId",
          "="
        ],
        "syntactic_label": "StringBuilder Object and its methods",
        "semantic_tags": [
          "String Manipulation",
          "Object Representation",
          "Data Formatting",
          "Output Generation",
          "Logging"
        ],
        "description": "The tokens represent the use of the StringBuilder class in Java to construct strings.  The methods like Append, AppendFormat, and ToString are used to efficiently build strings by concatenating various data types and formatting elements. The resulting strings are often used for object representation (ToString overrides), data formatting for output, or generating log messages."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c364",
          "unique_tokens": [
            ".text",
            "_idEdit",
            ".nEntryCount",
            ";",
            "*",
            "sheet=",
            "}",
            "(",
            "originalText",
            "toString",
            "minTermFreq",
            "append",
            "]",
            ".",
            "assign",
            "sb",
            "name=",
            "calibrateSizeByDeletes=",
            "newObjectId",
            "=",
            "\"",
            "!",
            "colwidth",
            "rate:",
            ")",
            "return",
            "oldObjectId"
          ],
          "syntactic_label": "StringBuilder Object, Methods, Operators, Variables",
          "semantic_tags": [
            "String Manipulation",
            "Object Serialization",
            "Data Representation",
            "Output Formatting",
            "Logging"
          ],
          "description": "The tokens represent elements of C# code focused on constructing and manipulating strings using the StringBuilder class.  The '.' operator is used for method calls on StringBuilder objects (append, toString).  Variables like 'sb' store StringBuilder instances.  The tokens collectively demonstrate string building for various purposes, such as creating formatted output or representing data structures as strings.  The frequent use of toString() suggests the strings are intended for display or logging."
        }
      ]
    },
    "c479": {
      "encoder_cluster": {
        "id": "c479",
        "unique_tokens": [
          ".unused",
          "asIntBuffer",
          "DoubleBuffer",
          "null",
          "IsVerticalBorder",
          "int",
          "ShortToHex",
          "asDoubleBuffer",
          "CopyBuffer",
          "GetBuffer",
          "ReadWriteIntArrayBuffer",
          "CharacterBuffer",
          "skipBuffer",
          "idBuffer",
          "field_6_refs",
          ".ver",
          "ReadOnlyFloatArrayBuffer",
          ".wOffset",
          "IdBuffer",
          "ReadOnlyIntArrayBuffer",
          "[/RECALCID]",
          "ToHexString",
          "NewLine",
          "colwidth",
          "ReadOnlyCharArrayBuffer",
          "asFloatBuffer",
          "bufferLength",
          "ShortBuffer",
          "ReadWriteLongArrayBuffer",
          "CharBuffer",
          "m_buffer",
          "ReadOnlyLongArrayBuffer",
          "messageBuffer",
          "asShortBuffer",
          "buffer",
          ")",
          "\"",
          "new",
          "asCharBuffer",
          "k",
          ".is16bit",
          "resultBuffer",
          "asLongBuffer",
          "HexDump",
          "FmtOverflowBuffer",
          "==",
          "=",
          "if",
          "Buffer",
          "IsDisplayAsPercentage",
          "ReadOnlyShortArrayBuffer",
          "inputBuffer",
          "green",
          "NextBuffer",
          "LongBuffer",
          "StringUtil",
          "FloatBuffer",
          "0",
          "}",
          "returnBuffer",
          ",",
          "enlargeBuffer",
          "IntBuffer",
          ".",
          "newSize",
          "GetEntryPathBuffer",
          "GetTextBuffer",
          "Append",
          "zzBuffer",
          "ToString",
          "asReadOnlyBuffer",
          "overflowBuffer",
          "Size",
          "\\n",
          ";",
          "(",
          "OutputFromResultBuffer",
          "ReadWriteShortArrayBuffer",
          "ToHex",
          "scratchBuffer",
          "NewCharacterBuffer",
          "ReadInputToBuffer",
          "[/STRING]",
          "bufferPosition",
          "TemporaryBuffer",
          "otherBuffer",
          "Length",
          "ReadOnlyDoubleArrayBuffer",
          "position",
          "ReadWriteFloatArrayBuffer",
          "BuildYear",
          "badBuffer",
          ".horizPos",
          "ReadWriteDoubleArrayBuffer",
          "[",
          ".char_offset=",
          "ReadWriteCharArrayBuffer"
        ],
        "syntactic_label": "Java Tokens and Operators",
        "semantic_tags": [
          "Buffer Manipulation",
          "Data Structures",
          "Input/Output Operations",
          "String Processing",
          "Error Handling"
        ],
        "description": "The tokens represent a diverse set of Java language elements, primarily focused on buffer manipulation and string processing.  They include various buffer types (IntBuffer, DoubleBuffer, CharBuffer, etc.), operators (=, ==), keywords (if, return), and methods (Append, ToString, etc.).  The code snippets demonstrate common operations such as creating, manipulating, and reading data from buffers, converting data types, and handling potential errors (e.g., BufferOverflowException). The semantic tags reflect the core functionalities observed in the provided code examples."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c103",
          "unique_tokens": [
            "ReadWriteCharArrayBuffer",
            "'",
            "inputBuffer",
            "getTextBuffer",
            "CharacterBuffer",
            "asReadOnlyBuffer",
            "otherBuffer",
            "buffer",
            "returnBuffer",
            "CharBuffer",
            "asLongBuffer",
            "asCharBuffer",
            ".",
            "skipBuffer",
            "set",
            "bufferLength",
            "==",
            "isAutoSize",
            "messageBuffer",
            "asIntBuffer",
            "intToHex",
            "DoubleBuffer",
            "nextBuffer",
            "zzBuffer",
            ";",
            "+",
            "(",
            "scratchBuffer",
            "newSize",
            "ReadOnlyDoubleArrayBuffer",
            "fmtOverflowBuffer",
            "append",
            "HexDump",
            "ShortBuffer",
            "idBuffer",
            "currentBlockCardinality",
            "ReadWriteFloatArrayBuffer",
            "ReadWriteShortArrayBuffer",
            "pool",
            "lowerBuffer",
            "ReadOnlyShortArrayBuffer",
            "Integer",
            "ReadWriteDoubleArrayBuffer",
            "Buffer",
            "chars",
            "getBuildYear",
            "bufferPosition",
            "ReadOnlyLongArrayBuffer",
            "length",
            "IntBuffer",
            "0x",
            "toHexString",
            "overflowBuffer",
            "FloatBuffer",
            "readInputToBuffer",
            "0",
            "}",
            "new",
            "enlargeBuffer",
            "startIndex",
            "Size",
            "newCharacterBuffer",
            "LongBuffer",
            "getProperty",
            ".salt",
            "resultBuffer",
            "System",
            "ReadOnlyIntArrayBuffer",
            "=",
            "asShortBuffer",
            "position",
            "[/RECALCID]",
            "getEntryPathBuffer",
            "ReadWriteLongArrayBuffer",
            "[",
            "null",
            "badBuffer",
            "toString",
            ",",
            "internalBuffer",
            "ReadOnlyCharArrayBuffer",
            "titleBuffer",
            "ReadWriteIntArrayBuffer",
            "\\n",
            "ReadOnlyFloatArrayBuffer",
            "\"",
            "newBuffer",
            "asFloatBuffer",
            "copyBuffer",
            "full",
            "asDoubleBuffer",
            "outputFromResultBuffer",
            ")",
            "return"
          ],
          "syntactic_label": "Buffer Objects and Operators",
          "semantic_tags": [
            "Buffer Management",
            "Data Handling",
            "Input/Output Operations",
            "String Manipulation",
            "Data Structures"
          ],
          "description": "The tokens represent various buffer objects (e.g., ReadWriteCharArrayBuffer, DoubleBuffer, IntBuffer) and operators (e.g., ., +, =, ==) used extensively in C# for managing and manipulating data within buffers.  These are crucial for efficient data handling, especially in scenarios involving large datasets or stream processing. The context shows operations like creating, allocating, reading, writing, appending, and comparing buffer contents.  The semantic tags reflect the core functionalities observed in the code snippets."
        }
      ]
    },
    "c498": {
      "encoder_cluster": {
        "id": "c498",
        "unique_tokens": [
          ">=",
          "1",
          "fis",
          "Next",
          "Count",
          "ToString",
          ";",
          "subs",
          "(",
          "--",
          "null",
          "suffixes",
          "++",
          "GetPromptText",
          "GetType",
          "start",
          "index",
          "+",
          "<",
          "i",
          "n",
          "HasNext",
          "numDecisions",
          "0",
          "active",
          ")",
          "Length",
          "\"",
          "l=",
          "nCells",
          "3",
          "}",
          "map",
          ",",
          "is",
          ".",
          "serializerClasses",
          "s",
          "]",
          "stop",
          "names",
          "-",
          "b",
          "CFRuleRecord",
          "rules",
          "Append",
          "==",
          "[",
          "="
        ],
        "syntactic_label": "Operators, Variables, and Method Calls",
        "semantic_tags": [
          "Looping and Iteration",
          "Data Processing",
          "Conditional Logic",
          "Array Manipulation",
          "Data Structures"
        ],
        "description": "The tokens represent a mix of operators (+, -, <, >, ==, =, ++, --), variables (i, n, fis, Count, Length, numDecisions, etc.), and method calls (Append, Encode, Decode, ContainsCell, GetPromptText, GetType, etc.).  These are fundamental elements in Java used to construct loops (for), perform conditional checks (if), manipulate arrays, and work with various data structures. The sentences show common programming patterns like iterating through arrays, performing bitwise operations, and implementing search algorithms."
      },
      "aligned_decoder_clusters": [
        {
          "id": "c111",
          "unique_tokens": [
            "'",
            "<",
            "instanceof",
            "rules",
            "null",
            "val",
            ";",
            "+",
            ">=",
            "0",
            "subs",
            "}",
            "(",
            "fis",
            "-",
            "toString",
            "serializerClasses",
            "buffer",
            "index",
            "terms",
            "valuesPerBlock",
            ",",
            ":",
            "toIndex",
            "i",
            "--",
            "]",
            "append",
            "++",
            "bitsPerValue",
            "utf8ToString",
            ".",
            "&&",
            "CTFormat",
            "rs",
            "b",
            ">",
            "==",
            "=",
            "\"",
            "{",
            "nCells",
            "3",
            "length",
            ")",
            "return"
          ],
          "syntactic_label": "C# Tokens and Symbols",
          "semantic_tags": [
            "Looping and Iteration",
            "String Manipulation",
            "Array Processing",
            "Conditional Logic",
            "Data Structures"
          ],
          "description": "The tokens represent a wide range of C# language constructs.  Many are used in loops (for, ++, --), array manipulation (array indexing, length property), string building (StringBuilder, append, toString), conditional statements (if, ==, <, >, >=, &&), and general data structure usage (arrays, lists, objects).  The semantic tags reflect the common operations performed in the provided code snippets."
        }
      ]
    }
  }
}